//===--- LoggingWrappers.swift.gyb ----------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
from gyb_stdlib_support import TRAVERSALS, collectionForTraversal
}%

import StdlibUnittest

public protocol Wrapper {
  associatedtype Base
  init(wrapping base: Base)
  var base: Base { get set }
}

public protocol LoggingType : Wrapper {
  associatedtype Log : AnyObject
}

extension LoggingType {
  public var log: Log.Type {
    return Log.self
  }
  
  public var selfType: Any.Type {
    return self.dynamicType
  }
}

//===----------------------------------------------------------------------===//
// Iterator
//===----------------------------------------------------------------------===//

public class IteratorLog {
  public static func dispatchTester<I : IteratorProtocol>(
    _ iterator: I
  ) -> LoggingIterator<LoggingIterator<I>> {
    return LoggingIterator(wrapping: LoggingIterator(wrapping: iterator))
  }
  public static var next = TypeIndexed(0)
}

public struct LoggingIterator<Base : IteratorProtocol>
  : IteratorProtocol, LoggingType {

  public typealias Log = IteratorLog
  
  public init(wrapping base: Base) {
    self.base = base
  }
  
  public mutating func next() -> Base.Element? {
    Log.next[selfType] += 1
    return base.next()
  }
  
  public var base: Base
}

//===----------------------------------------------------------------------===//
// Sequence and Collection logs
//===----------------------------------------------------------------------===//

public class SequenceLog {
  public static func dispatchTester<S : Sequence>(
    s: S
  ) -> LoggingSequence<LoggingSequence<S>> {
    return LoggingSequence(wrapping: LoggingSequence(wrapping: s))
  }
  public static var makeIterator = TypeIndexed(0)
  public static var underestimatedCount = TypeIndexed(0)
  public static var map = TypeIndexed(0)
  public static var filter = TypeIndexed(0)
  public static var forEach = TypeIndexed(0)
  public static var dropFirst = TypeIndexed(0)
  public static var dropLast = TypeIndexed(0)
  public static var prefixMaxLength = TypeIndexed(0)
  public static var suffixMaxLength = TypeIndexed(0)
  public static var split = TypeIndexed(0)
  public static var _customContainsEquatableElement = TypeIndexed(0)
  public static var _preprocessingPass = TypeIndexed(0)
  public static var _copyToNativeArrayBuffer = TypeIndexed(0)
  public static var _copyContents = TypeIndexed(0)
}

public class CollectionLog : SequenceLog {
  public class func dispatchTester<C : Collection>(
    c: C
  ) -> LoggingCollection<LoggingCollection<C>> {
    return LoggingCollection(wrapping: LoggingCollection(wrapping: c))
  }
  public static var startIndex = TypeIndexed(0)
  public static var endIndex = TypeIndexed(0)
  public static var subscriptIndex = TypeIndexed(0)
  public static var subscriptRange = TypeIndexed(0)
  public static var _failEarlyRangeCheckIndex = TypeIndexed(0)
  public static var _failEarlyRangeCheckRange = TypeIndexed(0)
  public static var successor = TypeIndexed(0)
  public static var formSuccessor = TypeIndexed(0)
  public static var indices = TypeIndexed(0)
  public static var prefixUpTo = TypeIndexed(0)
  public static var prefixThrough = TypeIndexed(0)
  public static var suffixFrom = TypeIndexed(0)
  public static var isEmpty = TypeIndexed(0)
  public static var count = TypeIndexed(0)
  public static var _customIndexOfEquatableElement = TypeIndexed(0)
  public static var first = TypeIndexed(0)
  public static var advance = TypeIndexed(0)
  public static var advanceLimit = TypeIndexed(0)
  public static var distance = TypeIndexed(0)
}

public class BidirectionalCollectionLog : SequenceLog {
  public class func dispatchTester<C : BidirectionalCollection>(
    c: C
  ) -> LoggingBidirectionalCollection<LoggingBidirectionalCollection<C>> {
    return LoggingBidirectionalCollection(
      wrapping: LoggingBidirectionalCollection(wrapping: c))
  }
  public static var predecessor = TypeIndexed(0)
  public static var formPredecessor = TypeIndexed(0)
  public static var last = TypeIndexed(0)
}

public class MutableCollectionLog : CollectionLog {
  public class func dispatchTester<C : MutableCollection>(
    c: C
  ) -> LoggingMutableCollection<LoggingMutableCollection<C>> {
    return LoggingMutableCollection(
      wrapping: LoggingMutableCollection(wrapping: c))
  }
  public static var subscriptIndexSet = TypeIndexed(0)
  public static var subscriptRangeSet = TypeIndexed(0)
  public static var _withUnsafeMutableBufferPointerIfSupported = TypeIndexed(0)
  public static var _withUnsafeMutableBufferPointerIfSupportedNonNilReturns =
    TypeIndexed(0)
}

/// Data container to keep track of how many times each `Base` type calls methods
/// of `RangeReplaceableCollection`.
///
/// Each static variable is a mapping of Type -> Number of calls.
public class RangeReplaceableCollectionLog : CollectionLog {
  public static var init_ = TypeIndexed(0)
  public static var initRepeating = TypeIndexed(0)
  public static var initWithSequence = TypeIndexed(0)

  public static var _customRemoveLast = TypeIndexed(0)
  public static var _customRemoveLastN = TypeIndexed(0)
  public static var append = TypeIndexed(0)
  public static var appendContentsOf = TypeIndexed(0)
  public static var insert = TypeIndexed(0)
  public static var insertContentsOf = TypeIndexed(0)
  public static var removeAll = TypeIndexed(0)
  public static var removeAt = TypeIndexed(0)
  public static var removeFirst = TypeIndexed(0)
  public static var removeFirstN = TypeIndexed(0)
  public static var removeSubrange = TypeIndexed(0)
  public static var replaceSubrange = TypeIndexed(0)
  public static var reserveCapacity = TypeIndexed(0)

<<<<<<< HEAD
  public class func dispatchTester<C : RangeReplaceableCollection>(
    rrc: C
=======
  public static func dispatchTester<C: RangeReplaceableCollection>(
    _ rrc: C
>>>>>>> master
  ) -> LoggingRangeReplaceableCollection<LoggingRangeReplaceableCollection<C>> {
    return LoggingRangeReplaceableCollection(
      wrapping: LoggingRangeReplaceableCollection(wrapping: rrc)
    )
  }
}

//===----------------------------------------------------------------------===//
// Sequence and Collection that count method calls
//===----------------------------------------------------------------------===//

% for Kind in ['Sequence', 'Collection', 'MutableCollection', 'RangeReplaceableCollection']:
%   for Traversal in [''] if Kind == 'Sequence' else TRAVERSALS:
%     if Kind == 'Sequence':
%       Self = 'LoggingSequence'
%     else:
%       Self = 'Logging' + Kind.replace('Collection', collectionForTraversal(Traversal))
%     end
%     if Kind == 'Sequence':
%       Constraints = Kind
%       Protocols = Kind
%     else:
%       Constraints = 'protocol<' + Kind + ', ' + collectionForTraversal(Traversal) + '>'
%       Protocols = ', '.join(set([Kind, collectionForTraversal(Traversal)]))
%     end
/// Interposes between `${Kind}` method calls to increment each method's
/// counter.
public struct ${Self}<
  Base : ${Constraints}
> : ${Protocols}, LoggingType {

  public var base: Base

  public typealias Log = ${Kind}Log

  public init(wrapping base: Base) {
    self.base = base
  }

  public typealias Iterator = LoggingIterator<Base.Iterator>

<<<<<<< HEAD
  public func makeIterator() -> LoggingIterator<Base.Iterator> {
    Log.makeIterator[selfType] += 1
    return LoggingIterator(wrapping: base.makeIterator())
=======
  public subscript(position: Base.Index) -> Base.Iterator.Element {
    return base[position]
  }

  public mutating func replaceSubrange<
    C : Collection where C.Iterator.Element == Base.Iterator.Element
  >(
    _ bounds: Range<Base.Index>, with newElements: C
  ) {
    Log.replaceSubrange[selfType] += 1
    base.replaceSubrange(bounds, with: newElements)
  }

  public mutating func append(_ newElement: Base.Iterator.Element) {
    Log.append[selfType] += 1
    base.append(newElement)
  }

  public mutating func append<
    S : Sequence where S.Iterator.Element == Base.Iterator.Element
  >(contentsOf newElements: S) {
    Log.appendContentsOf[selfType] += 1
    base.append(contentsOf: newElements)
  }

  public mutating func insert(
    _ newElement: Base.Iterator.Element, at i: Base.Index
  ) {
    Log.insert[selfType] += 1
    base.insert(newElement, at: i)
  }

  @discardableResult
  public mutating func remove(at index: Base.Index) -> Base.Iterator.Element {
    Log.removeAt[selfType] += 1
    return base.remove(at: index)
  }

  public mutating func _customRemoveLast() -> Base.Iterator.Element? {
    Log._customRemoveLast[selfType] += 1
    return base._customRemoveLast()
  }

  public mutating func _customRemoveLast(_ n: Int) -> Bool {
    Log._customRemoveLastN[selfType] += 1
    return base._customRemoveLast(n)
  }

  @discardableResult
  public mutating func removeFirst() -> Base.Iterator.Element {
    Log.removeFirst[selfType] += 1
    return base.removeFirst()
  }

  public mutating func removeFirst(_ n: Int) {
    Log.removeFirstN[selfType] += 1
    base.removeFirst(n)
  }

  public mutating func removeSubrange(_ bounds: Range<Base.Index>) {
    Log.removeSubrange[selfType] += 1
    base.removeSubrange(bounds)
  }

  public mutating func removeAll(keepingCapacity keepCapacity: Bool) {
    Log.removeAll[selfType] += 1
    base.removeAll(keepingCapacity: keepCapacity)
  }

  public mutating func reserveCapacity(_ n: Base.Index.Distance) {
    Log.reserveCapacity[selfType] += 1
    base.reserveCapacity(n)
>>>>>>> master
  }

  public var underestimatedCount: Int {
    Log.underestimatedCount[selfType] += 1
    return base.underestimatedCount
  }

  @warn_unused_result
  public func map<T>(
    @noescape transform: (Base.Iterator.Element) throws -> T
  ) rethrows -> [T] {
    Log.map[selfType] += 1
    return try base.map(transform)
  }

  @warn_unused_result
  public func filter(
    @noescape includeElement: (Base.Iterator.Element) throws -> Bool
  ) rethrows -> [Base.Iterator.Element] {
    Log.filter[selfType] += 1
    return try base.filter(includeElement)
  }

<<<<<<< HEAD
  public func forEach(
    @noescape body: (Base.Iterator.Element) throws -> Void
  ) rethrows {
    Log.forEach[selfType] += 1
    try base.forEach(body)
=======
  public func makeIterator() -> Base.Iterator {
    return base.makeIterator()
  }
}

public class ForwardIndexLog {
  public static var successor = TypeIndexed(0)
  public static var advancedBy = TypeIndexed(0)
  public static var advancedByWithLimit = TypeIndexed(0)
  public static var distanceTo = TypeIndexed(0)

  public class func dispatchTester<I : ForwardIndex>(
    _ i: I
  ) -> LoggingForwardIndex<LoggingForwardIndex<I>> {
    return LoggingForwardIndex(LoggingForwardIndex(i))
  }
}

public class BidirectionalIndexLog : ForwardIndexLog {
  public static var predecessor = TypeIndexed(0)

  public class func dispatchTester<I : BidirectionalIndex>(
    _ i: I
  ) -> LoggingBidirectionalIndex<LoggingBidirectionalIndex<I>> {
    return LoggingBidirectionalIndex(LoggingBidirectionalIndex(i))
>>>>>>> master
  }

<<<<<<< HEAD
  public typealias SubSequence = Base.SubSequence

  public func dropFirst(n: Int) -> SubSequence {
    Log.dropFirst[selfType] += 1
    return base.dropFirst(n)
=======
public class RandomAccessIndexLog : BidirectionalIndexLog {
  public class func dispatchTester<I : RandomAccessIndex>(
    _ i: I
  ) -> LoggingRandomAccessIndex<LoggingRandomAccessIndex<I>> {
    return LoggingRandomAccessIndex(LoggingRandomAccessIndex(i))
  }
}

public class SequenceLog {
  public static func dispatchTester<S: Sequence>(
    _ s: S
  ) -> LoggingSequence<LoggingSequence<S>> {
    return LoggingSequence(LoggingSequence(s))
>>>>>>> master
  }

<<<<<<< HEAD
  public func dropLast(n: Int) -> SubSequence {
    Log.dropLast[selfType] += 1
    return base.dropLast(n)
=======
public class CollectionLog : SequenceLog {
  public class func dispatchTester<C : Collection>(
    _ c: C
  ) -> LoggingCollection<LoggingCollection<C>> {
    return LoggingCollection(LoggingCollection(c))
>>>>>>> master
  }

<<<<<<< HEAD
  public func prefix(maxLength: Int) -> SubSequence {
    Log.prefixMaxLength[selfType] += 1
    return base.prefix(maxLength)
=======
public class MutableCollectionLog : CollectionLog {
  public class func dispatchTester<C : MutableCollection>(
    _ c: C
  ) -> LoggingMutableCollection<LoggingMutableCollection<C>> {
    return LoggingMutableCollection(LoggingMutableCollection(c))
>>>>>>> master
  }

  public func suffix(maxLength: Int) -> SubSequence {
    Log.suffixMaxLength[selfType] += 1
    return base.suffix(maxLength)
  }

  public func split(
    maxSplits maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true,
    @noescape isSeparator: (Base.Iterator.Element) throws -> Bool
  ) rethrows -> [SubSequence] {
    Log.split[selfType] += 1
    return try base.split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      isSeparator: isSeparator)
  }

  public func _customContainsEquatableElement(
    element: Base.Iterator.Element
  ) -> Bool? {
    Log._customContainsEquatableElement[selfType] += 1
    return base._customContainsEquatableElement(element)
  }

  /// If `self` is multi-pass (i.e., a `Collection`), invoke
  /// `preprocess` on `self` and return its result.  Otherwise, return
  /// `nil`.
  public func _preprocessingPass<R>(
    @noescape preprocess: () throws -> R
  ) rethrows -> R? {
    Log._preprocessingPass[selfType] += 1
    return try base._preprocessingPass(preprocess)
  }

  /// Create a native array buffer containing the elements of `self`,
  /// in the same order.
  public func _copyToNativeArrayBuffer()
    -> _ContiguousArrayBuffer<Base.Iterator.Element> {
    Log._copyToNativeArrayBuffer[selfType] += 1
    return base._copyToNativeArrayBuffer()
  }

  /// Copy a Sequence into an array.
  public func _copyContents(
    initializing ptr: UnsafeMutablePointer<Base.Iterator.Element>
  ) -> UnsafeMutablePointer<Base.Iterator.Element> {
    Log._copyContents[selfType] += 1
    return base._copyContents(initializing: ptr)
  }

%     if Kind in ['Collection', 'MutableCollection', 'RangeReplaceableCollection']:
  public typealias Index = Base.Index

  public var startIndex: Index {
    Log.startIndex[selfType] += 1
    return base.startIndex
  }

  public var endIndex: Index {
    Log.endIndex[selfType] += 1
    return base.endIndex
  }

  public subscript(position: Index) -> Base.Iterator.Element {
    get {
      Log.subscriptIndex[selfType] += 1
      return base[position]
    }
%       if Kind == 'MutableCollection':
    set {
      Log.subscriptIndexSet[selfType] += 1
      base[position] = newValue
    }
%       end
  }

  public subscript(bounds: Range<Index>) -> SubSequence {
    get {
      Log.subscriptRange[selfType] += 1
      return base[bounds]
    }
%       if Kind == 'MutableCollection':
    set {
      Log.subscriptRangeSet[selfType] += 1
      base[bounds] = newValue
    }
%       end
  }

  public func _failEarlyRangeCheck(index: Index, bounds: Range<Index>) {
    Log._failEarlyRangeCheckIndex[selfType] += 1
    base._failEarlyRangeCheck(index, bounds: bounds)
  }

  public func _failEarlyRangeCheck(range: Range<Index>, bounds: Range<Index>) {
    Log._failEarlyRangeCheckRange[selfType] += 1
    base._failEarlyRangeCheck(range, bounds: bounds)
  }

  @warn_unused_result
  public func successor(of i: Index) -> Index {
    Log.successor[selfType] += 1
    return base.successor(of: i)
  }

  public func formSuccessor(i: inout Index) {
    Log.formSuccessor[selfType] += 1
    base.formSuccessor(&i)
  }

  public typealias Indices = Base.Indices

  public var indices: Indices {
    Log.indices[selfType] += 1
    return base.indices
  }

  public func prefix(upTo end: Index) -> SubSequence {
    Log.prefixUpTo[selfType] += 1
    return base.prefix(upTo: end)
  }

  public func prefix(through position: Index) -> SubSequence {
    Log.prefixThrough[selfType] += 1
    return base.prefix(through: position)
  }

  public func suffix(from start: Index) -> SubSequence {
    Log.suffixFrom[selfType] += 1
    return base.suffix(from: start)
  }

  public var isEmpty: Bool {
    Log.isEmpty[selfType] += 1
    return base.isEmpty
  }

  public typealias IndexDistance = Base.IndexDistance

  public var count: IndexDistance {
    Log.count[selfType] += 1
    return base.count
  }

  public func _customIndexOfEquatableElement(
<<<<<<< HEAD
    element: Base.Iterator.Element
  ) -> Index?? {
=======
    _ element: Base.Iterator.Element
  ) -> Base.Index?? {
>>>>>>> master
    Log._customIndexOfEquatableElement[selfType] += 1
    return base._customIndexOfEquatableElement(element)
  }

  public var first: Base.Iterator.Element? {
    Log.first[selfType] += 1
    return base.first
  }

  @warn_unused_result
  public func index(n: IndexDistance, stepsFrom i: Index) -> Index {
    Log.advance[selfType] += 1
    return base.index(n, stepsFrom: i)
  }

  @warn_unused_result
  public func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit: Index) -> Index {
    Log.advanceLimit[selfType] += 1
    return base.index(n, stepsFrom: i, limitedBy: limit)
  }

  @warn_unused_result
  public func distance(from start: Index, to end: Index) -> IndexDistance {
    Log.distance[selfType] += 1
    return base.distance(from: start, to: end)
  }
%     end

%     if Kind == 'MutableCollection':
  public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(
    @noescape _ body: (UnsafeMutablePointer<Iterator.Element>, Int) throws -> R
  ) rethrows -> R? {
    Log._withUnsafeMutableBufferPointerIfSupported[selfType] += 1
    let result = try base._withUnsafeMutableBufferPointerIfSupported(body)
    if result != nil {
      Log._withUnsafeMutableBufferPointerIfSupportedNonNilReturns[selfType] += 1
    }
    return result
  }
%     end

%     if Kind == 'RangeReplaceableCollection':
  public init() {
    self.base = Base()
    Log.init_[selfType] += 1
  }

  public init(repeating repeatedValue: Iterator.Element, count: Int) {
    self.base = Base(repeating: repeatedValue, count: count)
    Log.initRepeating[selfType] += 1
  }

<<<<<<< HEAD
  public init<
    S : Sequence where S.Iterator.Element == Iterator.Element
  >(_ elements: S) {
    self.base = Base(elements)
    Log.initWithSequence[selfType] += 1
  }

  public mutating func _customRemoveLast() -> Base.Iterator.Element? {
    Log._customRemoveLast[selfType] += 1
    return base._customRemoveLast()
  }

  public mutating func _customRemoveLast(n: Int) -> Bool {
    Log._customRemoveLastN[selfType] += 1
    return base._customRemoveLast(n)
  }

  public mutating func append(newElement: Base.Iterator.Element) {
    Log.append[selfType] += 1
    base.append(newElement)
  }

  public mutating func append<
    S : Sequence where S.Iterator.Element == Base.Iterator.Element
  >(contentsOf newElements: S) {
    Log.appendContentsOf[selfType] += 1
    base.append(contentsOf: newElements)
  }

  public mutating func insert(
    newElement: Base.Iterator.Element, at i: Index
  ) {
    Log.insert[selfType] += 1
    base.insert(newElement, at: i)
  }

  public mutating func insert<
    C : Collection where C.Iterator.Element == Base.Iterator.Element
  >(contentsOf newElements: C, at i: Index) {
    Log.insertContentsOf[selfType] += 1
    base.insert(contentsOf: newElements, at: i)
  }

  public mutating func removeAll(keepingCapacity keepCapacity: Bool) {
    Log.removeAll[selfType] += 1
    base.removeAll(keepingCapacity: keepCapacity)
=======
  public func forEach(
    @noescape _ body: (Base.Iterator.Element) throws -> Void
  ) rethrows {
    Log.forEach[selfType] += 1
    try base.forEach(body)
  }

  @warn_unused_result
  public func map<T>(
    @noescape _ transform: (Base.Iterator.Element) throws -> T
  ) rethrows -> [T] {
    Log.map[selfType] += 1
    return try base.map(transform)
  }

  @warn_unused_result
  public func filter(
    @noescape _ includeElement: (Base.Iterator.Element) throws -> Bool
  ) rethrows -> [Base.Iterator.Element] {
    Log.filter[selfType] += 1
    return try base.filter(includeElement)
  }

  public func dropFirst(_ n: Int) -> Base.SubSequence {
    Log.dropFirst[selfType] += 1
    return base.dropFirst(n)
  }

  public func dropLast(_ n: Int) -> Base.SubSequence {
    Log.dropLast[selfType] += 1
    return base.dropLast(n)
  }

  public func prefix(_ maxLength: Int) -> Base.SubSequence {
    Log.prefix[selfType] += 1
    return base.prefix(maxLength)
  }

  public func suffix(_ maxLength: Int) -> Base.SubSequence {
    Log.suffix[selfType] += 1
    return base.suffix(maxLength)
  }

  public func split(
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true,
    @noescape isSeparator: (Base.Iterator.Element) throws -> Bool
  ) rethrows -> [Base.SubSequence] {
    Log.split[selfType] += 1
    return try base.split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      isSeparator: isSeparator)
>>>>>>> master
  }

  public mutating func remove(at index: Index) -> Base.Iterator.Element {
    Log.removeAt[selfType] += 1
    return base.remove(at: index)
  }

  public mutating func removeFirst() -> Base.Iterator.Element {
    Log.removeFirst[selfType] += 1
    return base.removeFirst()
  }

  public mutating func removeFirst(n: Int) {
    Log.removeFirstN[selfType] += 1
    base.removeFirst(n)
  }

  public mutating func removeSubrange(bounds: Range<Index>) {
    Log.removeSubrange[selfType] += 1
    base.removeSubrange(bounds)
  }

  public mutating func replaceSubrange<
    C : Collection where C.Iterator.Element == Base.Iterator.Element
  >(
    bounds: Range<Index>, with newElements: C
  ) {
    Log.replaceSubrange[selfType] += 1
    base.replaceSubrange(bounds, with: newElements)
  }

  public mutating func reserveCapacity(n: IndexDistance) {
    Log.reserveCapacity[selfType] += 1
    base.reserveCapacity(n)
  }
%     end
%     if Traversal in ['Bidirectional', 'RandomAccess']:
  @warn_unused_result
  public func predecessor(of i: Index) -> Index {
    BidirectionalCollectionLog.predecessor[selfType] += 1
    return base.predecessor(of: i)
  }

  public func formPredecessor(i: inout Index) {
    BidirectionalCollectionLog.formPredecessor[selfType] += 1
    base.formPredecessor(&i)
  }

  public var last: Iterator.Element? {
    BidirectionalCollectionLog.last[selfType] += 1
    return base.last
  }
%     end
}
%   end
% end

//===----------------------------------------------------------------------===//
// Custom assertions
//===----------------------------------------------------------------------===//

public func expectCustomizable<
  T : Wrapper where
  T : LoggingType,
  T.Base : Wrapper, T.Base : LoggingType,
  T.Log == T.Base.Log
>(_: T, _ counters: TypeIndexed<Int>,
  //===--- TRACE boilerplate ----------------------------------------------===//
  @autoclosure _ message: () -> String = "",
  showFrame: Bool = true,
  stackTrace: SourceLocStack = SourceLocStack(),  
  file: String = #file, line: UInt = #line
) {
  let newTrace = stackTrace.pushIf(showFrame, file: file, line: line)
  expectNotEqual(0, counters[T.self], message(), stackTrace: newTrace)
  expectEqual(
    counters[T.self], counters[T.Base.self], message(), stackTrace: newTrace)
}

public func expectNotCustomizable<
  T : Wrapper where
  T : LoggingType,
  T.Base : Wrapper, T.Base : LoggingType,
  T.Log == T.Base.Log
>(_: T, _ counters: TypeIndexed<Int>,
  //===--- TRACE boilerplate ----------------------------------------------===//
  @autoclosure _ message: () -> String = "",
  showFrame: Bool = true,
  stackTrace: SourceLocStack = SourceLocStack(),  
  file: String = #file, line: UInt = #line
) {
  let newTrace = stackTrace.pushIf(showFrame, file: file, line: line)
  expectNotEqual(0, counters[T.self], message(), stackTrace: newTrace)
  expectEqual(0, counters[T.Base.self], message(), stackTrace: newTrace)
}
