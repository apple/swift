//===--- RangeExpression.swift.gyb ----------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// A type which can be used to slice a collection. A `RangeExpression` can 
/// convert itself to a `Range<Bound>` of indices within a given collection; 
/// the collection can then slice itself with that `Range`.
/// 
/// -Warning: The requirements of `RangeExpression` are likely to change 
///           in a future version of Swift. If you conform your own 
///           types to `RangeExpression`, be prepared to migrate them.
public protocol RangeExpression {
  /// The type of the bounds of the `Range` produced by this 
  /// type when used as a `RangeExpression`.
  associatedtype Bound : Comparable
  
  /// Returns `self` expressed as a `Range<Bound>` suitable for 
  /// slicing a collection with the indicated properties.
  /// 
  /// -Parameter bounds: The range of indices in the collection.
  ///                    Equivalent to `startIndex ..< endIndex`
  ///                    in `Collection`.
  /// 
  /// -Parameter offset: A function which can be used to add to or 
  ///                    subtract from a bound. Equivalent to 
  ///                    `index(_:offsetBy:)` in `Collection`.
  /// 
  /// -Returns: A `Range<Bound>` suitable for slicing a collection. 
  ///           The return value is *not* guaranteed to be inside 
  ///           `bounds`. Callers should apply the same preconditions 
  ///           to the return value as they would to a range provided 
  ///           directly by the user.
  /// 
  /// -Warning: This method is likely to be replaced in a future version of Swift.
  ///           If you are calling this method, we recommend using the 
  ///           `relative(to:)` extension method instead. If you are implementing 
  ///           it, be prepared to migrate your code.
  /// 
  /// -Recommended: `relative(to:)`
  // 
  // WORKAROUND SR-2158 - We want to have this requirement, but it triggers a generics bug
  // func relative<C: Indexable>(to collection: C) -> Range<Bound> where C.Index == Bound
  func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound>
}

extension RangeExpression {
  /// Returns `self` expressed as a range of indices within `collection`.
  /// 
  /// -Parameter collection: The collection `self` should be 
  ///                        relative to.
  /// 
  /// -Returns: A `Range<Bound>` suitable for slicing `collection`. 
  ///           The return value is *not* guaranteed to be inside 
  ///           its bounds. Callers should apply the same preconditions 
  ///           to the return value as they would to a range provided 
  ///           directly by the user.
  /// 
  /// -RecommendedOver: `relative(to:offsettingBy:)`
  public func relative<C: Indexable>(to collection: C) -> Range<Bound> where C.Index == Bound {
    let bounds = Range(uncheckedBounds: (lower: collection.startIndex, upper: collection.endIndex))
    return relative(to: bounds, offsettingBy: collection.index(_:offsetBy:))
  }
}

extension Range: RangeExpression {
  public func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound> {
    return self
  }
}

extension CountableRange: RangeExpression {
  public func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound> {
    return Range(self)
  }
}

extension ClosedRange: RangeExpression {
  public func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound> {
    return Range(uncheckedBounds: (lower: lowerBound, upper: offset(upperBound, 1)))
  }
}

extension CountableClosedRange: RangeExpression {
  public func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound> {
    return CountableRange(self).relative(to: bounds, offsettingBy: offset)
  }
}

extension IncompleteRange: RangeExpression {
  public func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound> {
    return completed(by: bounds)
  }
}

extension IncompleteClosedRange: RangeExpression {
  public func relative<BoundDistance: SignedInteger>(to bounds: Range<Bound>, offsettingBy offset: (Bound, BoundDistance) -> Bound) -> Range<Bound> {
    let closedBounds = ClosedRange(uncheckedBounds: (bounds.lowerBound, bounds.upperBound))
    return completed(by: closedBounds).relative(to: bounds, offsettingBy: offset)
  }
}

// WORKAROUND SR-115 - Should be generic subscripts, not generated code for each conforming type
% for R in ['CountableRange', 'ClosedRange', 'CountableClosedRange', 'IncompleteRange', 'IncompleteClosedRange']:
// WORKAROUND rdar://25214066 - should be on Collection
extension Indexable
% if 'Countable' in R:
  where Index : Strideable, Index.Stride : SignedInteger
% end
{
  /// Accesses a contiguous subrange of the collection's elements.
  ///
  /// The accessed slice uses the same indices for the same elements as the
  /// original collection. Always use the slice's `startIndex` property
  /// instead of assuming that its indices start at a particular value.
  ///
  /// This example demonstrates getting a slice of an array of strings, finding
  /// the index of one of the strings in the slice, and then using that index
  /// in the original array.
  ///
  ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
  ///     let streetsSlice = streets[2 ..< streets.endIndex]
  ///     print(streetsSlice)
  ///     // Prints "["Channing", "Douglas", "Evarts"]"
  ///
  ///     let index = streetsSlice.index(of: "Evarts")    // 4
  ///     print(streets[index!])
  ///     // Prints "Evarts"
  ///
  /// - Parameter bounds: A range of the collection's indices. The bounds of
  ///   the range must be valid indices of the collection.
  public subscript(bounds: ${R}<Index>) -> SubSequence {
    get {
      return self[bounds.relative(to: self)]
    }
  }
}

// WORKAROUND rdar://25214066 - should be on Collection
extension MutableIndexable
% if 'Countable' in R:
  where Index : Strideable, Index.Stride : SignedInteger
% end
{
  /// Accesses a contiguous subrange of the collection's elements.
  ///
  /// The accessed slice uses the same indices for the same elements as the
  /// original collection. Always use the slice's `startIndex` property
  /// instead of assuming that its indices start at a particular value.
  ///
  /// This example demonstrates getting a slice of an array of strings, finding
  /// the index of one of the strings in the slice, and then using that index
  /// in the original array.
  ///
  ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
  ///     let streetsSlice = streets[2 ..< streets.endIndex]
  ///     print(streetsSlice)
  ///     // Prints "["Channing", "Douglas", "Evarts"]"
  ///
  ///     let index = streetsSlice.index(of: "Evarts")    // 4
  ///     streets[index!] = "Eustace"
  ///     print(streets[index!])
  ///     // Prints "Eustace"
  ///
  /// - Parameter bounds: A range of the collection's indices. The bounds of
  ///   the range must be valid indices of the collection.
  public subscript(bounds: ${R}<Index>) -> SubSequence {
    get {
      return self[bounds.relative(to: self)]
    }
    set {
      self[bounds.relative(to: self)] = newValue
    }
  }
}

% end
extension RangeReplaceableCollection {
  /// Replaces the specified subrange of elements with the given collection.
  ///
  /// This method has the effect of removing the specified range of elements
  /// from the collection and inserting the new elements at the same location.
  /// The number of new elements need not match the number of elements being
  /// removed.
  ///
  /// In this example, three elements in the middle of an array of integers are
  /// replaced by the five elements of a `Repeated<Int>` instance.
  ///
  ///      var nums = [10, 20, 30, 40, 50]
  ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
  ///      print(nums)
  ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
  ///
  /// If you pass a zero-length range as the `subrange` parameter, this method
  /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
  /// the `insert(contentsOf:at:)` method instead is preferred.
  ///
  /// Likewise, if you pass a zero-length collection as the `newElements`
  /// parameter, this method removes the elements in the given subrange
  /// without replacement. Calling the `removeSubrange(_:)` method instead is
  /// preferred.
  ///
  /// Calling this method may invalidate any existing indices for use with this
  /// collection.
  ///
  /// - Parameters:
  ///   - subrange: The subrange of the collection to replace. The bounds of
  ///     the range must be valid indices of the collection.
  ///   - newElements: The new elements to add to the collection.
  ///
  /// - Complexity: O(*m*), where *m* is the combined length of the collection
  ///   and `newElements`. If the call to `replaceSubrange` simply appends the
  ///   contents of `newElements` to the collection, the complexity is O(*n*),
  ///   where *n* is the length of `newElements`.
  public mutating func replaceSubrange<R, C>(
    _ subrange: R,
    with newElements: C
  ) where R : RangeExpression, R.Bound == Index, C : Collection, C.Iterator.Element == Iterator.Element {
    replaceSubrange(subrange.relative(to: self), with: newElements)
  }

  /// Removes the elements in the specified subrange from the collection.
  ///
  /// All the elements following the specified position are moved to close the
  /// gap. This example removes two elements from the middle of an array of
  /// measurements.
  ///
  ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
  ///     measurements.removeSubrange(1..<3)
  ///     print(measurements)
  ///     // Prints "[1.2, 1.5]"
  ///
  /// Calling this method may invalidate any existing indices for use with this
  /// collection.
  ///
  /// - Parameter bounds: The range of the collection to be removed. The
  ///   bounds of the range must be valid indices of the collection.
  ///
  /// - Complexity: O(*n*), where *n* is the length of the collection.
  public mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, R.Bound == Index {
    removeSubrange(bounds.relative(to: self))
  }
}