//===--- SIMDVectorTypes.swift.gyb ----------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2018 - 2019 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
from SwiftIntTypes import all_integer_types
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8
storagescalarCounts = [2,4,8,16,32,64]
vectorscalarCounts = storagescalarCounts + [3]
spelledNumbers = {
  2: 'two', 4: 'four', 8: 'eight', 16: '16', 32: '32', 64: '64',
  3: 'three'
}
ordinalPositions = ['first', 'second', 'third', 'fourth']
}%

%for n in vectorscalarCounts:
% storageN = 4 if n == 3 else n
/// A vector of ${spelledNumbers[n]} scalar values.
@_fixed_layout
public struct SIMD${n}<Scalar>: SIMD where Scalar: SIMDScalar {

  public var _storage: Scalar.SIMD${storageN}Storage

  public typealias MaskStorage = SIMD${n}<Scalar.SIMDMaskScalar>

  /// The number of scalars in the vector.
  @_transparent
  public var scalarCount: Int {
    return ${n}
  }

  /// Creates a vector with zero in all lanes.
  @_transparent
  public init() {
    _storage = Scalar.SIMD${storageN}Storage()
  }

  /// Accesses the scalar at the specified position.
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }

  /// Creates a new vector from the given elements.
  @_transparent
  public init(${', '.join(['_ v' + str(i) + ': Scalar' for i in range(n)])}) {
    self.init()
% for i in range(n):
    self[${i}] = v${i}
% end
  }

% if n <= 4:
  /// Creates a new vector from the given elements.
  ///
  /// - Parameters:
%  for i in range(n):
  ///   - ${'xyzw'[i]}: The ${ordinalPositions[i]} element of the vector.
%  end
  @_transparent
  public init(${', '.join([c + ': Scalar' for c in 'xyzw'[:n]])}) {
    self.init(${', '.join('xyzw'[:n])})
  }

%  for i in range(n):
  /// The ${ordinalPositions[i]} element of the vector.
  @_transparent
  public var ${'xyzw'[i]}: Scalar {
    @_transparent get { return self[${i}]}
    @_transparent set { self[${i}] = newValue }
  }

%  end
% end
% if n >= 4:
  /// Creates a new vector from two half-length vectors.
  @_transparent
  public init(lowHalf: SIMD${n/2}<Scalar>, highHalf: SIMD${n/2}<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }

%  for (half,indx) in [('low','i'), ('high',str(n/2)+'+i'), ('even','2*i'), ('odd','2*i+1')]:
  /// A half-length vector made up of the ${half} elements of the vector.
  public var ${half}Half: SIMD${n/2}<Scalar> {
    @inlinable get {
      var result = SIMD${n/2}<Scalar>()
      for i in result.indices { result[i] = self[${indx}] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[${indx}] = newValue[i] }
    }
  }

%  end
% end
}

extension SIMD${n} where Scalar: FixedWidthInteger {
  /// Creates a new vector from the given vector, truncating the bit patterns
  /// of the given vector's elements if necessary.
  ///
  /// - Parameter other: The vector to convert.
  @inlinable
  public init<Other>(truncatingIfNeeded other: SIMD${n}<Other>)
  where Other: FixedWidthInteger {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }

  /// Creates a new vector from the given vector, clamping the values of the
  /// given vector's elements if necessary.
  ///
  /// - Parameter other: The vector to convert.
  @inlinable
  public init<Other>(clamping other: SIMD${n}<Other>)
  where Other: FixedWidthInteger {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }

  /// Creates a new vector from the given vector, rounding the given vector's
  /// of elements using the specified rounding rule.
  ///
  /// - Parameters:
  ///   - other: The vector to convert.
  ///   - rule: The round rule to use when converting elements of `other.` The
  ///     default is `.towardZero`.
  @inlinable
  public init<Other>(
    _ other: SIMD${n}<Other>,
    rounding rule: FloatingPointRoundingRule = .towardZero
  )
  where Other: BinaryFloatingPoint {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}

extension SIMD${n}: CustomDebugStringConvertible {
  public var debugDescription: String {
    return "SIMD${n}<\(Scalar.self)>(${', '.join(map(lambda c:
                       '\\(self['+ str(c) + '])',
                       xrange(n)))})"
  }
}

extension SIMD${n} where Scalar: BinaryFloatingPoint {
  /// Creates a new vector from the given vector of integers.
  ///
  /// - Parameter other: The vector to convert.
  @inlinable
  public init<Other>(_ other: SIMD${n}<Other>)
  where Other: FixedWidthInteger {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }

  /// Creates a new vector from the given vector of floating-point values.
  ///
  /// - Parameter other: The vector to convert.
  @inlinable
  public init<Other>(_ other: SIMD${n}<Other>)
  where Other: BinaryFloatingPoint {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}

// Don't think I need to conform Scalar to SIMDScalar since it already is being done
// it seems in SIMDVectorTypes.swift
extension SIMD${n} : AdditiveArithmetic where Scalar: FloatingPoint /*& SIMDScalar*/ {
  public static var zero: SIMD${n} {
    return SIMD${n}()
  }
}

//extension SIMD${n} : VectorNumeric where Scalar : AdditiveArithmetic & FloatingPoint {}

//extension SIMD${n}
//  where Scalar : Differentiable,
//  Scalar.CotangentVector : SIMDScalar,
//  Scalar.TangentVector : SIMDScalar {
//  // Same implementation as DifferentiableView in Array.swift
//  @_fixed_layout // BART_TODO: what's this for?
//  public struct VectorView : Differentiable {
//    private var _base: SIMD${n}
//
//    // The viewed SIMD vector
//    // I'm implementing this as a computed property instead of directly
//    // exposing `_base` because the `@differentiable` annotation does not make
//    // the stored property actually differentiable. I think this is a bug.
//    // Maybe it's related to `@_fixed_layout`?
//    // TODO: Determine if that is a bug, and fix.
//    public var base: SIMD${n} {
//      @differentiable(wrt: self, vjp: _vjpBase)
//      get { return _base }
//      _modify { yield &_base }
//    }
//
//    @usableFromInline
//    func _vjpBase() ->
//    (SIMD${n}, (SIMD${n}<Scalar>.CotangentVector) -> CotangentVector) {
//      return (base, { $0 })
//    }
//
//    /// Creates a differentiable view of the given SIMD vector.
//    @differentiable(wrt: base, vjp: _vjpInit)
//    public init(_ base: SIMD${n}) { self._base = base }
//
//    @usableFromInline
//    static func _vjpInit(_ base: SIMD${n}) ->
//    (SIMD${n}.VectorView, (CotangentVector) -> CotangentVector) {
//      return (SIMD${n}.VectorView(base), { $0 })
//    }
//
//    // MARK: - Differentiable conformance.
//
//    public typealias TangentVector =
//    SIMD${n}<Scalar.TangentVector>.VectorView
//    public typealias CotangentVector =
//    SIMD${n}<Scalar.CotangentVector>.VectorView // ???????
//    public typealias AllDifferentiableVariables =
//    SIMD${n}<Scalar.AllDifferentiableVariables>.VectorView
//
//    public var allDifferentiableVariables: AllDifferentiableVariables {
//      get {
//        return AllDifferentiableVariables(
//        base.map { $0.allDifferentiableVariables })
//      }
//      set {
//        precondition(
//        base.count == newValue.base.count,
//        "cannot set \(SIMD${n}).VectorView.AllDifferentiableVariables " +
//        "with count \(base.count) to " +
//        "\(SIMD${n}).VectorView.AllDifferentiableVariables with " +
//        "different count \(newValue.base.count)")
//        for i in base.indices {
//          base[i].allDifferentiableVariables = newValue.base[i]
//        }
//      }
//    }
//
//    public func moved(along direction: TangentVector) -> VectorView {
//      precondition(
//      base.count == direction.base.count,
//      "cannot move \(SIMD${n}).VectorView with count \(base.count) along " +
//      "direction with different count \(direction.base.count)")
//      return VectorView(
//      zip(base, direction.base).map { $0.moved(along: $1) })
//    }
//
//    public func tangentVector(from cotangentVector: CotangentVector) ->
//    TangentVector {
//      precondition(
//      base.count == cotangentVector.base.count,
//      "cannot use \(SIMD${n}).VectorView with count \(base.count) to " +
//      "get tangentVector from cotangentVector with different count " +
//      "\(cotangentVector.base.count)")
//      return TangentVector(zip(base, cotangentVector.base).map {
//        (selfElement, cotangentVectorElement) in
//        selfElement.tangentVector(from: cotangentVectorElement)
//      })
//    }
//  }
//}
//
///// Makes `SIMD${n}` differentiable as the product manifold of `Scalar`
///// multiplied with itself `count` times.
//extension SIMD${n} : Differentiable
//  where Scalar : Differentiable,
//  Scalar.CotangentVector : SIMDScalar,
//  Scalar.TangentVector : SIMDScalar {
//  // In an ideal world, `TangentVector`, `CotangentVector`, and
//  // `AllDifferentiableVariables` would all be `SIMD${n}`s. Unfortunately, we
//  // can't conform `SIMD${n}` to `AdditiveArithmetic` for `TangentVector` and
//  // `CotangentVector`, because `SIMD${n}` already has a static `+` method with
//  // different semantics from `AdditiveArithmetic` `+`. So we use
//  // `SIMD${n}.VectorView` for all these associated types.
//  public typealias TangentVector =
//  SIMD${n}<Scalar.TangentVector>.VectorView
//  public typealias CotangentVector =
//  SIMD${n}<Scalar.CotangentVector>.VectorView
//  public typealias AllDifferentiableVariables =
//  SIMD${n}<Scalar.AllDifferentiableVariables>.VectorView
//
//  public var allDifferentiableVariables: AllDifferentiableVariables {
//    get {
//      return VectorView(self).allDifferentiableVariables
//    }
//    set {
//      var view = VectorView(self)
//      view.allDifferentiableVariables = newValue
//      self = view.base
//    }
//  }
//
//  public func moved(along direction: TangentVector) -> Array {
//    return VectorView(self).moved(along: direction).base
//  }
//
//  public func tangentVector(from cotangentVector: CotangentVector) ->
//  TangentVector {
//    return VectorView(self).tangentVector(from: cotangentVector)
//  }
//}

%end

extension SIMD3 {
  /// A three-element vector created by appending a scalar to a two-element vector.
  @_alwaysEmitIntoClient
  public init(_ xy: SIMD2<Scalar>, _ z: Scalar) {
    self.init(xy.x, xy.y, z)
  }
}

extension SIMD4 {
  /// A four-element vector created by appending a scalar to a three-element vector.
  @_alwaysEmitIntoClient
  public init(_ xyz: SIMD3<Scalar>, _ w: Scalar) {
    self.init(xyz.x, xyz.y, xyz.z, w)
  }
}

%for self_type in all_integer_types(word_bits):
% Self = self_type.stdlib_name
% BuiltinName = self_type.builtin_name
% Mask = Self if self_type.is_signed else self_type.get_opposite_signedness().stdlib_name
extension ${Self}: SIMDScalar {

  public typealias SIMDMaskScalar = ${Mask}

% for n in storagescalarCounts:
%  bytes = n * self_type.bits / 8
  /// Storage for a vector of ${spelledNumbers[n]} integers.
  @_fixed_layout
  @_alignment(${bytes if bytes <= 16 else 16})
  public struct SIMD${n}Storage: SIMDStorage {

    public var _value: Builtin.Vec${n}x${BuiltinName}

    @_transparent
    public var scalarCount: Int {
      return ${n}
    }

    @_transparent
    public init() {
      _value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Self} {
      @_transparent
      get {
        return ${Self}(Builtin.extractelement_Vec${n}x${BuiltinName}_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent
      set {
        _value = Builtin.insertelement_Vec${n}x${BuiltinName}_${BuiltinName}_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
  }

% end
}

%end

%for (Self, bits) in [('Float',32), ('Double',64)]:
extension ${Self}: SIMDScalar {

  public typealias SIMDMaskScalar = Int${bits}

% for n in storagescalarCounts:
%  bytes = n * bits / 8
  /// Storage for a vector of ${spelledNumbers[n]} floating-point values.
  @_fixed_layout
  @_alignment(${bytes if bytes <= 16 else 16})
  public struct SIMD${n}Storage: SIMDStorage {

    public var _value: Builtin.Vec${n}xFPIEEE${bits}

    @_transparent
    public var scalarCount: Int {
      return ${n}
    }

    @_transparent
    public init() {
      _value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Self} {
      @_transparent
      get {
        return ${Self}(Builtin.extractelement_Vec${n}xFPIEEE${bits}_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent
      set {
        _value = Builtin.insertelement_Vec${n}xFPIEEE${bits}_FPIEEE${bits}_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
  }

% end
}

%end
