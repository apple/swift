//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
def cmp(a, b, p):
  if p:
    return "isOrderedBefore(" + a + ", " + b + ")"
  else:
    return "(" + a + " < " + b + ")"

}%

// Generate two versions of sorting functions: one with an explicitly passed
// predicate 'isOrderedBefore' and the other for Comparable types that don't
// need such a predicate.
% preds = [True, False]
% for p in preds:
%{
if p:
  orderingRequirement = """\
/// - Requires: `isOrderedBefore` is a
///   [strict weak ordering](http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings)
///   over `elements`."""
  according = " according to `isOrderedBefore`"
else:
  orderingRequirement = """\
/// - Requires: The less-than operator (`func <`) defined in the `Comparable`
///   conformance is a [strict weak ordering](http://en.wikipedia.org/wiki/Strict_weak_order#Strict_weak_orderings)
///   over `elements`."""
  according = ""
}%

func _insertionSort<
  C: MutableCollectionType where C.Index: BidirectionalIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) {
  if !range.isEmpty {
    let start = range.startIndex

    // Keep track of the end of the initial sequence of sorted
    // elements.
    var sortedEnd = start

    // One element is trivially already-sorted, thus pre-increment
    // Continue until the sorted elements cover the whole sequence
    sortedEnd._successorInPlace()
    while sortedEnd != range.endIndex {
      // get the first unsorted element
      let x: C.Generator.Element = elements[sortedEnd]

      // Look backwards for x's position in the sorted sequence,
      // moving elements forward to make room.
      var i = sortedEnd
      repeat {
        let predecessor: C.Generator.Element = elements[i.predecessor()]

        // if x doesn't belong before y, we've found its position
        if !${cmp("x", "predecessor", p)} {
          break
        }

        // Move y forward
        elements[i] = predecessor
        i._predecessorInPlace()
      } while i != start

      if i != sortedEnd {
        // Plop x into position
        elements[i] = x
      }
      sortedEnd._successorInPlace()
    }
  }
}

/// Re-order the given `range` of `elements` and return a pivot index
/// *p*.
///
/// - Postcondition: For all *i* in `range.startIndex..<`*p*, and *j*
///   in *p*`..<range.endIndex`, `less(elements[`*i*`],
///   elements[`*j*`]) && !less(elements[`*j*`],
/// elements[`*p*`])`.  Only returns `range.endIndex` when
/// `elements` is empty.
${orderingRequirement}
@available(*, unavailable, message="call the 'partition()' method on the collection")
public func partition<
  C: MutableCollectionType where C.Index: RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"_ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) -> C.Index {
  fatalError("unavailable function can't be called")
}

func _partition<
  C: MutableCollectionType where C.Index: RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) -> C.Index {
  var lo = range.startIndex
  var hi = range.endIndex

  if lo == hi {
    return lo
  }

  // The first element is the pivot.
  let pivot = elements[range.startIndex]

  // Loop invariants:
  // * lo < hi
  // * elements[i] < pivot, for i in range.startIndex+1..lo
  // * pivot <= elements[i] for i in hi..range.endIndex

Loop: while true {
  FindLo: repeat {
      lo._successorInPlace()
      while lo != hi {
        if !${cmp("elements[lo]", "pivot", p)} { break FindLo }
        lo._successorInPlace()
      }
      break Loop
    } while false

  FindHi: repeat {
      hi._predecessorInPlace()
      while hi != lo {
        if ${cmp("elements[hi]", "pivot", p)} { break FindHi }
        hi._predecessorInPlace()
      }
      break Loop
    } while false

    swap(&elements[lo], &elements[hi])
  }

  lo._predecessorInPlace()
  if lo != range.startIndex {
    // swap the pivot into place
    swap(&elements[lo], &elements[range.startIndex])
  }

  return lo
}

public // @testable
func _introSort<
  C : MutableCollectionType where C.Index : RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"_ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) {
%   if p:
  var comp = isOrderedBefore
%   end
  let len = range.count.toIntMax()
  if len < 2 {
    return
  }
  // Set max recursion depth to 2*floor(log(N)), as suggested in the introsort
  // paper: http://www.cs.rpi.edu/~musser/gp/introsort.ps
  let depthLimit = 2 * _floorLog2(Int64(len))
  _introSortImpl(&elements, range, ${"&comp," if p else ""} depthLimit)
}

func _introSortImpl<
  C : MutableCollectionType where C.Index : RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""},
  _ depthLimit: Int
) {

  // Insertion sort is better at handling smaller regions.
  if range.count < 20 {
    _insertionSort(&elements, range ${", &isOrderedBefore" if p else ""})
    return
  }
  if depthLimit == 0 {
    _heapSort(&elements, range ${", &isOrderedBefore" if p else ""})
    return
  }

  // Partition and sort.
  // We don't check the depthLimit variable for underflow because this variable
  // is always greater than zero (see check above).
  let partIdx: C.Index = _partition(&elements, range
                                    ${", &isOrderedBefore" if p else ""})
  _introSortImpl(&elements, range.startIndex..<partIdx,
                 ${"&isOrderedBefore, " if p else ""} depthLimit &- 1);
  _introSortImpl(&elements, (partIdx.successor())..<range.endIndex,
                 ${"&isOrderedBefore, " if p else ""} depthLimit &- 1);
}

func _siftDown<
  C : MutableCollectionType where C.Index : RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ index: C.Index,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) {
  let countToIndex = (range.startIndex..<index).count
  let countFromIndex = (index..<range.endIndex).count
  // Check if left child is within bounds. If not, return, because there are
  // no children of the given node in the heap.
  if countToIndex + 1 >= countFromIndex {
    return
  }
  let left = index.advancedBy(countToIndex + 1)
  var largest = index
  if ${cmp("elements[largest]", "elements[left]", p)} {
    largest = left
  }
  // Check if right child is also within bounds before trying to examine it.
  if countToIndex + 2 < countFromIndex {
    let right = left + 1
    if ${cmp("elements[largest]", "elements[right]", p)} {
      largest = right
    }
  }
  // If a child is bigger than the current node, swap them and continue sifting
  // down.
  if largest != index {
    swap(&elements[index], &elements[largest])
    _siftDown(&elements, largest, range ${", &isOrderedBefore" if p else ""})
  }
}
func _heapify<
  C : MutableCollectionType where C.Index : RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) {
  // Here we build a heap starting from the lowest nodes and moving to the root.
  // On every step we sift down the current node to obey the max-heap property:
  //   parent >= max(leftChild, rightChild)
  //
  // We skip the rightmost half of the array, because these nodes don't have
  // any children.
  let root = range.startIndex
  var node = root.advancedBy(C.Index.Distance(range.count.toIntMax()/2))
  while node != root {
    node._predecessorInPlace()
    _siftDown(&elements, node, range ${", &isOrderedBefore" if p else ""})
  }
}
func _heapSort<
  C : MutableCollectionType where C.Index : RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout elements: C,
  _ range: Range<C.Index> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) {
  var hi = range.endIndex
  let lo = range.startIndex
  _heapify(&elements, range ${", &isOrderedBefore" if p else ""})
  hi._predecessorInPlace()
  while hi != lo {
    swap(&elements[lo], &elements[hi])
    _siftDown(&elements, lo, lo..<hi ${", &isOrderedBefore" if p else ""})
    hi._predecessorInPlace()
  }
}

%{
if p:
    sortIsUnstable = """\
/// The sorting algorithm is not stable (can change the relative order of
/// elements for which `isOrderedBefore` does not establish an order)."""
else:
    sortIsUnstable = """\
/// The sorting algorithm is not stable (can change the relative order of
/// elements that compare equal)."""

}%

/// Sort `collection` in-place${according}.
///
${sortIsUnstable}
///
${orderingRequirement}
@available(*, unavailable, message="call the 'sortInPlace()' method on the collection")
public func sort<
  C: MutableCollectionType where C.Index: RandomAccessIndexType
  ${"" if p else ", C.Generator.Element : Comparable"}
>(
  inout collection: C ${"," if p else ""}
  ${"_ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) {
  fatalError("unavailable function can't be called")
}

/// Sort `array` in-place${according}.
///
${sortIsUnstable}
///
${orderingRequirement}
% if p:
@available(*, unavailable, message="call the 'sortInPlace()' method on the collection")
public func sort<T>(inout array: [T], _ isOrderedBefore: (T, T) -> Bool) {
% else:
@available(*, unavailable, message="call the 'sortInPlace()' method on the collection")
public func sort<T : Comparable>(inout array: [T]) {
% end
  fatalError("unavailable function can't be called")
}

/// Sort `array` in-place${according}.
///
${sortIsUnstable}
///
${orderingRequirement}
% if p:
@available(*, unavailable, message="call the 'sortInPlace()' method on the collection")
public func sort<T>(
  inout array: ContiguousArray<T>,
  _ isOrderedBefore: (T, T) -> Bool
) {
% else:
@available(*, unavailable, message="call the 'sortInPlace()' method on the collection")
public func sort<T : Comparable>(inout array: ContiguousArray<T>) {
% end
  fatalError("unavailable function can't be called")
}

/// Return an `Array` containing the sorted elements of `source`${according}.
///
${sortIsUnstable}
///
${orderingRequirement}
@available(*, unavailable, message="call the 'sort()' method on the collection")
public func sorted<
  C: SequenceType${"" if p else " where C.Generator.Element : Comparable"}
>(
  source: C ${"," if p else ""}
  ${"_ isOrderedBefore: (C.Generator.Element, C.Generator.Element) -> Bool" if p else ""}
) -> [C.Generator.Element] {
  fatalError("unavailable function can't be called")
}


/// Performs a binary search in `from`..<`to` for the value at `val`,
/// preserving the lower ordering of `val` in case of equal matches.
///
/// - Requires: The values in `from`..<`to` must already be in order.
/// - Returns: The stable insertion point for the value in `val`.
private func _stableSearchWithLower<
  T${"" if p else ": Comparable"}
>(
  from: UnsafeMutablePointer<T>,
  _ to: UnsafeMutablePointer<T>,
  _ val: UnsafeMutablePointer<T> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (T, T) -> Bool" if p else ""}
) -> UnsafeMutablePointer<T> {
  var from = from
  var count = to - from
  while count > 0 {
    let half = count / 2
    let mid = from + half
    if ${cmp("mid.memory", "val.memory", p)} {
      from = mid + 1
      count = count - half - 1
    } else {
      count = half
    }
  }
  return from
}

/// Performs a binary search in `from`..<`to` for the value at `val`,
/// preserving the upper ordering of `val` in case of equal matches.
///
/// - Requires: The values in `from`..<`to` must already be in order.
/// - Returns: The stable insertion point for the value in `val`.
private func _stableSearchWithUpper<
  T${"" if p else ": Comparable"}
>(
  from: UnsafeMutablePointer<T>,
  _ to: UnsafeMutablePointer<T>,
  _ val: UnsafeMutablePointer<T> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (T, T) -> Bool" if p else ""}
) -> UnsafeMutablePointer<T> {
  var from = from
  var count = to - from
  while count > 0 {
    let half = count / 2
    let mid = from + half
    if ${cmp("val.memory", "mid.memory", p)} {
      count = half
    } else {
      from = mid + 1
      count = count - half - 1
    }
  }
  return from
}

/// Merges two consecutive, previously sorted ranges of elements.
///
/// The algorithm merges elements in place by choosing new pivots in the
/// two ranges, such that elements between the lower pivot and the midpoint
/// are ordered after the elements between the midpoint and the upper range.
///
/// For example:
///
///     var a = [1, 3, 5, 7, 9, 11, 13, 2, 4, 6, 8, 10]
///              ~~~~~~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~
///     // (from, pivot, to) == (0, 7, 12)
///     lowerPivot = 3     // value 7
///     upperPivot = 9     // value 6
///
/// The elements in `lowerPivot`...`upperPivot` are then *rotated* so the
/// original pivot element ends up at the position of `lowerPivot`:
///
///     _rotate(&a, lowerPivot, pivot, upperPivot)
///     // a == [1, 3, 5, 2, 4, 6, 7, 9, 11, 13, 8, 10]
///              ~~~~~~~  ~~~~~~~  ~~~~~~~~~~~~  ~~~~~
///              ================  ===================
///
/// Finally, the two new pairs of consecutive, sorted ranges are merged
/// recursively.
///
/// - Requires: The values in `from`..<`pivot` and `pivot`..<`to` must
///   already be in order.
private func _stableMerge<
  T${"" if p else ": Comparable"}
>(
  from: UnsafeMutablePointer<T>,
  _ pivot: UnsafeMutablePointer<T>,
  _ to: UnsafeMutablePointer<T>,
  _ lowerCount: Int,
  _ upperCount: Int ${"," if p else ""}
  ${"inout _ isOrderedBefore: (T, T) -> Bool" if p else ""}
) {
  switch (lowerCount, upperCount) {
  // If one group has zero length, no merge needed
  case (_, 0), (0, _):
    return
    
  // Two elements might be flipped
  case (1, 1):
    if ${cmp("pivot.memory", "from.memory", p)} {
      swap(&pivot.memory, &from.memory)
    }
    return
  
  // Three elements are trivial to merge
  case (1, 2):
    let upper = to - 1
    if ${cmp("pivot.memory", "from.memory", p)} {
      if !${cmp("upper.memory", "from.memory", p)} {    // 2 / 1, 3
        swap(&pivot.memory, &from.memory)
      } else {                                          // 3 / 1, 2
        (from.memory, pivot.memory, upper.memory)
          = (pivot.memory, upper.memory, from.memory)
      }
    }
    return
  case (2, 1):
    let second = from + 1
    if ${cmp("pivot.memory", "second.memory", p)} {
      if !${cmp("pivot.memory", "from.memory", p)} {    // 1, 3 / 2
        swap(&second.memory, &pivot.memory)
      } else {                                          // 2, 3 / 1
        (from.memory, second.memory, pivot.memory)
          = (pivot.memory, from.memory, second.memory)
      }
    }
    return
  
  default: break
  }
  
  let lowerPivot: UnsafeMutablePointer<T>
  let upperPivot: UnsafeMutablePointer<T>
  let (lowerFirstCount, lowerSecondCount): (Int, Int)
  
  // The first pivot chosen will be in the middle of the larger range
  if lowerCount > upperCount {
    // Choose a new lower pivot in the middle of the lower range
    lowerFirstCount = lowerCount / 2
    lowerPivot = from + lowerFirstCount
    // Find an upper pivot such that elements in the upper range below
    // `upperPivot` are all ordered before the elements in the lower range
    // *above* `lowerPivot`.
    upperPivot = _stableSearchWithLower(pivot, to,
                      lowerPivot ${", &isOrderedBefore" if p else ""})
    lowerSecondCount = upperPivot - pivot
  } else {
    // Same as above, just reversed
    lowerSecondCount = upperCount / 2
    upperPivot = pivot + lowerSecondCount
    lowerPivot = _stableSearchWithUpper(from, pivot,
                      upperPivot ${", &isOrderedBefore" if p else ""})
    lowerFirstCount = lowerPivot - from
  }
  
  // Perform the rotation and adjust the midpoint
  _rotate(lowerPivot, pivot, upperPivot)
  let midpoint = lowerPivot + lowerSecondCount
  
  _stableMerge(from, lowerPivot, midpoint,
        lowerFirstCount, lowerSecondCount ${", &isOrderedBefore" if p else ""})
  _stableMerge(midpoint, upperPivot, to,
        lowerCount - lowerFirstCount, upperCount - lowerSecondCount
        ${", &isOrderedBefore" if p else ""})
}

/// Performs a stable sort on the elements in the range `from`..<`to`.
///
/// Smaller ranges are sorted via insertion sort, larger ranges are divided
/// for sorting recursively, then the sorted pieces are merged.
func _stableSortImpl<
  T${"" if p else ": Comparable"}
>(
  from: UnsafeMutablePointer<T>,
  _ to: UnsafeMutablePointer<T> ${"," if p else ""}
  ${"inout _ isOrderedBefore: (T, T) -> Bool" if p else ""}
) {
  let count = to - from
  
  // Use an insertion sort for small runs
  if count < 12 {
    var buffer = UnsafeMutableBufferPointer(start: from, count: count)
    _insertionSort(&buffer, buffer.indices ${", &isOrderedBefore" if p else ""})
    return
  }
  
  // Recursively sort the top and bottom halves
  let middle = from + count / 2
  _stableSortImpl(from, middle ${", &isOrderedBefore" if p else ""})
  _stableSortImpl(middle, to ${", &isOrderedBefore" if p else ""})
  
  // Merge the top and bottom
  _stableMerge(from, middle, to, middle - from, to - middle ${", &isOrderedBefore" if p else ""})
}

// A Swift implementation of a Java port of the STL's stable sort
// via http://thomas.baudel.name/Visualisation/VisuTri/inplacestablesort.html

/// Performs a stable sort on the elements in the range `from`..<`to`.
func _stableSort<
  T${"" if p else ": Comparable"}
>(
  from: UnsafeMutablePointer<T>,
  _ to: UnsafeMutablePointer<T> ${"," if p else ""}
  ${"_ isOrderedBefore: (T, T) -> Bool" if p else ""}
) {
% if p:
  var comp = isOrderedBefore
% end
  _stableSortImpl(from, to ${", &comp" if p else ""})
}

% end
// for p in preds

/// Returns the greatest common denominator for `m` and `n`.
private func _gcd (m: Int, _ n: Int) -> Int {
  var (m, n) = (m, n)
  while n != 0 {
    let t = m % n
    m = n
    n = t
  }
  return m
}

/// Rotates the contents of memory in `from`..<`to` left so that the
/// value at `mid` is now at `from`. Lower elements wrap back to the upper
/// end of the range.
///
/// For example:
///
///     var a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
///     a.withUnsafeMutableBufferPointer { b in
///       let from = b.baseAddress
///       _rotate(from, from + 3, from + b.count)
///     }
///     // a == [4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
private func _rotate<T>(
  from: UnsafeMutablePointer<T>,
  _ mid: UnsafeMutablePointer<T>,
  _ to: UnsafeMutablePointer<T>
) {
  if from == mid || mid == to { return }
  var n = _gcd(to - from, mid - from)
  while n != 0 {
    n -= 1
    let val = (from + n).memory
    let shift = mid - from
    var (p1, p2) = (from + n, from + n + shift)
    while p2 != from + n {
      p1.memory = p2.memory
      p1 = p2
      if to - p2 > shift {
        p2 += shift
      } else {
        p2 = from + (shift - (to - p2))
      }
    }
    p1.memory = val
  }
}

/// Exchange the values of `a` and `b`.
///
/// - Requires: `a` and `b` do not alias each other.
public func swap<T>(inout a : T, inout _ b : T) {
  // Semantically equivalent to (a, b) = (b, a).
  // Microoptimized to avoid retain/release traffic.
  let p1 = Builtin.addressof(&a)
  let p2 = Builtin.addressof(&b)
  _debugPrecondition(
    p1 != p2,
    "swapping a location with itself is not supported")

  // Take from P1.
  let tmp : T = Builtin.take(p1)
  // Transfer P2 into P1.
  Builtin.initialize(Builtin.take(p2) as T, p1)
  // Initialize P2.
  Builtin.initialize(tmp, p2)
}
