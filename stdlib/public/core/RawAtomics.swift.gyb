//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
  word_size = int(CMAKE_SIZEOF_VOID_P)

  allOrderings = [
    # Swift enum case,         Capitalized API name,    documentation name,        llvm name,   failure name, isLoad, isStore
    ('relaxed',                'Relaxed',               'relaxed',                 'monotonic', 'monotonic',  True,   True),
    ('acquiring',              'Acquiring',             'acquiring',               'acquire',   'acquire',    True,   False),
    ('releasing',              'Releasing',             'releasing',               'release',   'monotonic',  False,  True),
    ('acquiringAndReleasing',  'AcquiringAndReleasing', 'acquiring-and-releasing', 'acqrel',    'acquire',    False,  False),
    ('sequentiallyConsistent', '',                      'sequentially consistent', 'seqcst',    'seqcst',     True,   True)
  ]

  def loadOrderings():
    for (enumOrder, capitalOrder, docOrder, llvmOrder, failureOrder, isLoad, isStore) in allOrderings:
      if isLoad:
        yield (enumOrder, capitalOrder, docOrder, llvmOrder)

  def storeOrderings():
    for (enumOrder, capitalOrder, docOrder, llvmOrder, failureOrder, isLoad, isStore) in allOrderings:
      if isStore:
        yield (enumOrder, capitalOrder, docOrder, llvmOrder)

  integerOperations = [
    ('Add', '&+'),
    ('And', '&'),
    ('Or', '|'),
    ('Xor', '^')
  ]
}%

extension UnsafeMutableRawPointer {
% for (enumOrder, capitalOrder, docOrder, llvmOrder) in loadOrderings():
  /// Atomically load the pointee with ${docOrder} ordering.
  @_alwaysEmitIntoClient
  @_transparent
  public // backdeployment
  func _atomic${capitalOrder}LoadWord() -> Int {
    return Int(Builtin.atomicload_${llvmOrder}_Word(_rawValue))
  }
% end
}

extension UnsafeMutableRawPointer {
% for enumOrder, capitalOrder, docOrder, llvmOrder in storeOrderings():
  /// Atomically store the specified value in the memory referenced by this
  /// pointer, with ${docOrder} ordering.
  @_alwaysEmitIntoClient
  @_transparent
  public // backdeployment
  func _atomic${capitalOrder}StoreWord(_ desired: Int) {
    Builtin.atomicstore_${llvmOrder}_Word(_rawValue, desired._builtinWordValue)
  }
% end
}

extension UnsafeMutableRawPointer {
% for _, capitalOrder, docOrder, llvmOrder, failureOrder, _, _ in allOrderings:
  @_alwaysEmitIntoClient
  @_transparent
  public // backdeployment
  func _atomic${capitalOrder}CompareExchangeWord(
    expected: inout Int,
    desired: Int
  ) -> Bool {
    let (oldValue, won) = Builtin.cmpxchg_${llvmOrder}_${failureOrder}_Word(
      _rawValue, expected._builtinWordValue, desired._builtinWordValue)
    expected = Int(oldValue)
    return Bool(won)
  }
% end
}

extension UnsafeMutableRawPointer {
% for (operationName, operator) in integerOperations:
%   for _, capitalOrder, docOrder, llvmOrder, _, _, _ in allOrderings:
  @_alwaysEmitIntoClient
  @_transparent
  public // backdeployment
  func _atomic${capitalOrder}FetchThen${operationName}Word(_ operand: Int) -> Int {
    let value = Builtin.atomicrmw_${operationName.lower()}_${llvmOrder}_Word(
      _rawValue, operand._builtinWordValue)
    return Int(value)
  }
%   end
% end
}

//------------------------------------------------------------------------------

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension UnsafeMutableRawPointer {
  @_transparent
  public func _atomicLoadWord(ordering: AtomicMemoryOrdering) -> Int {
    switch ordering {
    case .relaxed:
      return _atomicRelaxedLoadWord()
    case .acquiring:
      return _atomicAcquiringLoadWord()
    case .sequentiallyConsistent:
      return _atomicLoadWord()
    case .releasing, .acquiringAndReleasing:
      _preconditionFailure("invalid memory ordering for atomic load")
    default:
      return _atomicLoadWord()
    }
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension UnsafeMutableRawPointer {
  @_transparent
  public func _atomicStoreWord(_ desired: Int, ordering: AtomicMemoryOrdering) {
    switch ordering {
    case .relaxed:
      _atomicRelaxedStoreWord(desired)
    case .releasing:
      _atomicReleasingStoreWord(desired)
    case .sequentiallyConsistent:
      _atomicStoreWord(desired)
    case .acquiring, .acquiringAndReleasing:
      _preconditionFailure("invalid memory ordering for atomic store")
    @unknown default:
      _atomicStoreWord(desired)
    }
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension UnsafeMutableRawPointer {
  @_transparent
  public func _atomicCompareExchangeWord(
    expected: inout Int,
    desired: Int,
    ordering: AtomicMemoryOrdering
  ) -> Bool {
    switch ordering {
    case .relaxed:
      return _atomicRelaxedCompareExchangeWord(
        expected: &expected,
        desired: desired)
    case .acquiring:
      return _atomicAcquiringCompareExchangeWord(
        expected: &expected,
        desired: desired)
    case .releasing:
      return _atomicReleasingCompareExchangeWord(
        expected: &expected,
        desired: desired)
    case .acquiringAndReleasing:
      return _atomicAcquiringAndReleasingCompareExchangeWord(
        expected: &expected,
        desired: desired)
    case .sequentiallyConsistent:
      return _atomicCompareExchangeWord(
        expected: &expected,
        desired: desired)
    @unknown default:
      return _atomicCompareExchangeWord(
        expected: &expected,
        desired: desired)
    }
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension UnsafeMutableRawPointer {
% for (operationName, op) in integerOperations:
  @_transparent
  @discardableResult
  public func _atomicFetchThen${operationName}Word(
    _ operand: Int,
    ordering: AtomicMemoryOrdering
  ) -> Int {
    switch ordering {
    case .relaxed:
      return _atomicRelaxedFetchThen${operationName}Word(operand)
    case .acquiring:
      return _atomicAcquiringFetchThen${operationName}Word(operand)
    case .releasing:
      return _atomicReleasingFetchThen${operationName}Word(operand)
    case .acquiringAndReleasing:
      return _atomicAcquiringAndReleasingFetchThen${operationName}Word(operand)
    case .sequentiallyConsistent:
      return _atomicFetchThen${operationName}Word(operand)
    @unknown default:
      return _atomicFetchThen${operationName}Word(operand)
    }
  }

% end
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension UnsafeMutableRawPointer {
% for (operationName, op) in integerOperations:
  @_transparent
  @discardableResult
  public func _atomic${operationName}ThenFetchWord(
    _ operand: Int,
    ordering: AtomicMemoryOrdering = .sequentiallyConsistent
  ) -> Int {
    let old = _atomicFetchThen${operationName}Word(operand, ordering: ordering)
    return old ${op} operand
  }

% end
}
