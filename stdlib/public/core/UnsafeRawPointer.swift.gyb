//===--- UnsafeRawPointer.swift.gyb --------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%import gyb

% for mutable in (True, False):
%  Self = 'UnsafeMutableRawPointer' if mutable else 'UnsafeRawPointer'
%  a_Self = 'an `UnsafeMutableRawPointer`' if mutable else 'an `UnsafeRawPointer`'
%  Mutable = 'Mutable' if mutable else ''

/// A raw pointer for accessing untyped data. This provides no
/// automatic memory management, no type safety, and no alignment
/// guarantees. This implements Strideable to provide a view
/// of byte-addressable memory.
@_fixed_layout
public struct Unsafe${Mutable}RawPointer : Strideable, Hashable, _Pointer {
  /// The underlying raw pointer.
  public let _rawValue: Builtin.RawPointer

  /// Convert a builtin raw pointer to a Unsafe${Mutable}RawPointer.
  @_transparent
  public init(_ _rawValue : Builtin.RawPointer) {
    self._rawValue = _rawValue
  }

  /// Convert an opaque pointer to ${a_Self}.
  @_transparent
  public init(_ other : OpaquePointer) {
    _rawValue = other._rawValue
  }

  /// Convert an opaque pointer to ${a_Self}.
  ///
  /// Returns nil if `from` is nil.
  @_transparent
  public init?(_ other : OpaquePointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }

  /// Construct ${a_Self} with a given pattern of bits.
  @_transparent
  public init?(bitPattern: Int) {
    if bitPattern == 0 { return nil }
    _rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }

  /// Construct ${a_Self} with a given pattern of bits.
  @_transparent
  public init?(bitPattern: UInt) {
    if bitPattern == 0 { return nil }
    _rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }

  /// Convert an Unsafe${Mutable}Pointer ${a_Self}.
  @_transparent
  public init<T>(_ other : Unsafe${Mutable}Pointer<T>) {
    _rawValue = other._rawValue
  }

  /// Convert an Unsafe${Mutable}Pointer ${a_Self}.
  ///
  /// Returns nil if `other` is nil.
  @_transparent
  public init?<T>(_ other : Unsafe${Mutable}Pointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }

%  if not mutable:
  /// Convert an UnsafeMutableRawPointer ${a_Self}.
  @_transparent
  public init(_ other : UnsafeMutableRawPointer) {
    _rawValue = other._rawValue
  }

  /// Convert an UnsafeMutableRawPointer ${a_Self}.
  ///
  /// Returns nil if `other` is nil.
  @_transparent
  public init?(_ other : UnsafeMutableRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }

  /// Convert an UnsafeMutablePointer ${a_Self}.
  @_transparent
  public init<T>(_ other : UnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }

  /// Convert an UnsafeMutablePointer ${a_Self}.
  ///
  /// Returns nil if `other` is nil.
  @_transparent
  public init?<T>(_ other : UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
%  end # !mutable

%  if mutable:
  /// Allocate and point at uninitialized memory for `size` bytes with
  /// `alignedTo` alignment.
  ///
  /// - Postcondition: The memory is allocated, but not initialized.
  public static func allocate(
    bytes size: Int, alignedTo: Int = Int(Builtin.alignof(Double.self)))
  -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        size._builtinWordValue, alignedTo._builtinWordValue))
  }
%  end # mutable

  /// Deallocate uninitialized memory allocated for `bytes` number of bytes with
  /// `alignedTo` alignment.
  ///
  /// - Precondition: The memory is not initialized.
  ///
  /// - Postcondition: The memory has been deallocated.
  public func deallocate(bytes: Int,
    alignedTo: Int = Int(Builtin.alignof(Double.self))) {
    Builtin.deallocRaw(
      _rawValue, bytes._builtinWordValue, alignedTo._builtinWordValue)
  }
  
  /// Binding the allocated memory to type `T`.
  /// Returns an Unsafe${Mutable}Pointer<T> to the bound memory at `self`.
  ///  
  /// - Precondition: The memory is uninitialized.
  ///
  /// - Postcondition: The memory is bound to 'T' starting at `self` continuing
  ///   through `self` + `capacity` * `strideof(T.self)`
  ///
  /// - Warning: Binding memory to a type is potentially undefined if the
  ///   memory is ever accessed as an unrelated type.
  @_transparent
  public func bindMemory<T>(to: T.Type, capacity: Int)
      -> Unsafe${Mutable}Pointer<T> {
    // FIXME: call the builtin for binding memory
    return Unsafe${Mutable}Pointer<T>(_rawValue)
  }

  /// Convert from ${a_Self} to Unsafe${Mutable}Pointer<T> given that
  /// the region of memory starting at `self` is already bound to type `T`.
  ///
  /// - Precondition: The memory is bound to 'T' starting at `self` for some
  ///   unspecified capacity.
  ///
  /// - Warning: Accessing memory via the returned pointer is undefined if the
  ///   if the memory has not been bound to `T`.
  @_transparent
  public func assumingMemoryBound<T>(to: T.Type) -> Unsafe${Mutable}Pointer<T> {
    return Unsafe${Mutable}Pointer<T>(_rawValue)
  }

%  if mutable:
  /// Initialize this memory location with `count` consecutive copies
  /// of `newValue` of type `T`.
  ///
  /// Returns an `UnsafeMutablePointer<T>` to this memory.
  ///
  /// - Precondition: The memory is not initialized.
  ///
  /// - Precondition: The underlying pointer is properly aligned for
  ///                 accessing `T`.
  ///
  /// - Precondition: `count` is non-negative.
  ///
  /// - Postcondition: The memory is initialized; the value should eventually
  ///   be destroyed or moved from to avoid leaks.
  @discardableResult
  public func initialize<T>(_: T.Type, with value: T, count: Int = 1)
    -> UnsafeMutablePointer<T> {
    _debugPrecondition(count >= 0,
      "UnsafeMutableRawPointer.initialize(with:): negative count")

    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(value, nextPtr._rawValue)
      nextPtr += strideof(T.self)
    }
    return UnsafeMutablePointer(_rawValue)
  }

  /// Initialize the memory location at `index` with `newValue` as if this
  /// memory holds at least `index` + 1 contiguous values of type `T`.
  ///
  /// Returns an `UnsafeMutablePointer<T>` the single intialized
  /// in-memory element.
  ///
  /// - Precondition: The memory at `index` is not initialized.
  ///
  /// - Precondition: The underlying pointer is properly aligned for
  ///                 accessing `T`.
  ///
  /// - Postcondition: The memory is initialized; the value should eventually
  ///   be destroyed or moved from to avoid leaks.
  @discardableResult
  public func initialize<T>(toContiguous _: T.Type, atIndex index: Int,
    with value: T)
    -> UnsafeMutablePointer<T> {
    return (self + strideof(T.self) * index).initialize(T.self, with: value)
  }

  /// Initialize memory starting at `self` with `count` `T` values
  /// beginning at `from`, proceeding forward from `self` to `self +
  /// count - 1`.
  ///
  /// Returns an `UnsafeMutablePointer<T>` this memory.
  ///
  /// - Precondition: `count >= 0`
  ///
  /// - Precondition: `self` either precedes `source` or follows `source +
  ///   count - 1`.
  ///
  /// - Precondition: The memory at `self..<self + count` is uninitialized
  ///   and the `T` values at `source..<source + count` are
  ///   initialized.
  ///
  /// - Precondition: The underlying pointer is properly aligned for
  ///                 accessing `T`.
  ///
  /// - Postcondition: The `T` values at `self..<self + count` and
  ///   `source..<source + count` are initialized.
  @discardableResult
  public func initialize<T>(from source: UnsafePointer<T>, count: Int)
    -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0, "UnsafeMutableRawPointer.initialize with negative count")
    _debugPrecondition(
      UnsafeRawPointer(self) < UnsafeRawPointer(source)
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initialize non-following overlapping range")
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    return UnsafeMutablePointer(_rawValue)
  }

  /// Initialize memory starting at `self` with the `count` `T` values
  /// at `source`, proceeding backward from `self + count - 1` to
  /// `self`.
  ///
  /// Returns an `UnsafeMutablePointer<T>` this memory.
  ///
  /// Use `initializeBackwardFrom` when copying elements into later memory
  /// that may overlap with the source range.
  ///
  /// - Precondition: `count >= 0`
  ///
  /// - Precondition: `source` either precedes `self` or follows
  ///   `self + count - 1`.
  ///
  /// - Precondition: The `T` values at `self..<self + count` and
  ///   `source..<source + count` are initialized.
  @discardableResult
  public func initializeBackward<T>(from source: UnsafePointer<T>,
    count: Int)
    -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0, "UnsafeMutableRawPointer.initializeBackwardFrom with negative count")
    _debugPrecondition(
      UnsafeRawPointer(source) < UnsafeRawPointer(self)
      || UnsafeRawPointer(source)
         >= UnsafeRawPointer(self) + (count * strideof(T.self)),
      "UnsafeMutableRawPointer.initializeBackwardFrom non-preceding overlapping range; use initialize(from:) instead")
    var i = count - strideof(T.self)
    while i >= 0 {
      (self + i).initialize(T.self, with: source[i])
      i -= strideof(T.self)
    }
    return UnsafeMutablePointer(_rawValue)
  }

  /// Initialize memory starting at `self` with `count` `T` values
  /// beginning at `source`, proceeding forward from `self` to `self +
  /// count - 1`, and returning the source memory to an uninitialized
  /// state.
  ///
  /// Returns an `UnsafeMutablePointer<T>` this memory.
  ///
  /// - Precondition: `count >= 0`
  ///
  /// - Precondition: `self` either precedes `source` or follows `source +
  ///   count - 1`.
  ///
  /// - Precondition: The memory at `self..<self + count` is uninitialized
  ///   and the `Pointees` at `source..<source + count` are
  ///   initialized.
  ///
  /// - Postcondition: The `T` values at `self..<self + count` are
  ///   initialized and the memory at `source..<source + count` is
  ///   uninitialized.
  @discardableResult
  public func moveInitialize<T>(from source: UnsafeMutablePointer<T>,
    count: Int)
    -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0, "UnsafeMutableRawPointer.moveInitialize with negative count")
    _debugPrecondition(
      self < UnsafeMutableRawPointer(source)
      || self >= UnsafeMutableRawPointer(source) + count,
      "UnsafeMutableRawPointer.moveInitialize(from:) non-following overlapping range; use moveInitializeBackwardFrom")
    Builtin.takeArrayFrontToBack(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self + i).initialize(with: (source + i).move())
    // }
    return UnsafeMutablePointer(_rawValue)
  }

  /// Initialize memory starting at `self` with `count` `T` values
  /// beginning at `source`, proceeding backward from `self + count - 1`
  /// to `self`, and returning the source memory to an uninitialized
  /// state.
  ///
  /// Returns an `UnsafeMutablePointer<T>` this memory.
  ///
  /// - Precondition: `count >= 0`
  ///
  /// - Precondition: `source` either precedes `self` or follows
  ///   `self + count - 1`.
  ///
  /// - Precondition: The memory at `self..<self + count` is uninitialized
  ///   and the `Pointees` at `source..<source + count` are
  ///   initialized.
  ///
  /// - Postcondition: The `T` values at `self..<self + count` are
  ///   initialized and the memory at `source..<source + count` is
  ///   uninitialized.
  @discardableResult
  public func moveInitializeBackward<T>(from source: UnsafeMutablePointer<T>,
    count: Int)
    -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0, "UnsafeMutableRawPointer.moveInitializeBackward with negative count")
    _debugPrecondition(
      UnsafeMutableRawPointer(source) < self
      || UnsafeMutableRawPointer(source) >= self + count,
      "UnsafeMutableRawPointer.moveInitializeBackward non-preceding overlapping range; use moveInitialize(from:) instead")
    Builtin.takeArrayBackToFront(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // var src = source + count
    // var dst = self + count
    // while dst != self {
    //   (--dst).initialize(with: (--src).move())
    // }
    return UnsafeMutablePointer(_rawValue)
  }
%  end # mutable

  /// Load a single value of type `T` from raw memory.
  ///
  /// - Precondition: The underlying pointer is properly aligned for
  ///   accessing `T`.
  ///
  /// - Precondition: The memory is initialized to a value of some type, `U`,
  ///   such that `T` is layout compatible with `U`.
  ///
  /// - Note: The converse of loading a value, storing a value `T`
  ///   into initialized memory requires the user to know the
  ///   previously initialized value's type. Full 'store' semantics
  ///   can be achieved with:
  ///   `deinitialize(PreviousType)`
  ///   `initialize(NewType, with: value)`
  ///   If the previosly initialized type is trivial, then the
  ///   `deinitialize` call can be skipped.
  public func load<T>(_ : T.Type) -> T {
    return Builtin.load(_rawValue)
  }

  /// Load a single value of type `T` from memory at the given byte offset.
  ///
  /// - Precondition: The underlying pointer plus `offset` is properly
  ///   aligned for accessing `T`.
  ///
  /// - Precondition: The memory at `offset` is initialized to a value
  ///   of some type, `U`, such that `T` is layout compatible with `U`.
  public func load<T>(_ ty : T.Type, atByteOffset offset: Int) -> T {
    return (self + offset).load(ty)
  }

  /// Load a single value of type `T` at the specified `index` from
  /// this memory as if it contains at least `index` + 1 contiguous
  /// values of type `T`.
  ///
  /// - Precondition: The underlying pointer is properly aligned for
  ///                 accessing `T`.
  ///
  /// - Precondition: The memory at `index` is initialized to a value
  ///   of some type, `U`, such that `T` is layout compatible with `U`.
  public func load<T>(fromContiguous: T.Type, atIndex index: Int) -> T {
    return (self + strideof(T.self) * index).load(T.self)
  }

%  if mutable:
  /// Store a value's bytes into raw memory at `self`.
  ///  
  /// - Precondition: The underlying pointer is properly aligned for storing
  ///   type `T`.
  ///
  /// - Precondition: `T` is a trivial type.
  ///
  /// - Precondition: The memory is uninitialized, or initialized some
  ///   trivial type `U` such that `T` and `U` are mutually layout
  ///   compatible.
  /// 
  /// - Postcondition: The memory is initialized to raw bytes. If the
  ///   memory is bound to type `U`, then it now contains a value of
  ///   type `U`.
  ///
  /// - Note: A trivial type can be copied with just a bit-for-bit
  ///   copy without any indirection or reference-counting operations.
  ///   Generally, native Swift types that do not contain strong or
  ///   weak references or other forms of indirection are trivial, as
  ///   are imported C structs and enums.
  public func storeRaw<T>(_: T.Type, with value: T) {
    var temp = value
    withUnsafeMutablePointer(&temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        _rawValue, rawSrc, sizeof(T.self)._value,
        /*alignment:*/ Int32(0)._value,
        /*volatile:*/ false._value)
    }
  }
  
  /// Store a value's bytes into raw memory at the specified `index` from
  /// this memory as if it contains at least `index` + 1 contiguous
  /// values of type `T`.
  ///  
  /// - Precondition: The underlying pointer is properly aligned for storing
  ///   type `T`.
  ///
  /// - Precondition: `T` is a trivial type.
  ///
  /// - Precondition: The memory is uninitialized, or initialized some
  ///   trivial type `U` such that `T` and `U` are mutually layout
  ///   compatible.
  /// 
  /// - Postcondition: The memory is initialized to raw bytes. If the
  ///   memory is bound to type `U`, then it now contains a value of
  ///   type `U`.
  public func storeRaw<T>(toContiguous: T.Type, atIndex index: Int,
    with value: T) {
    (self + (strideof(T.self) * index)).storeRaw(T.self, with: value)
  }
  
  /// Read `count` contiguous values from of type `T` from `source` and
  /// store their raw bytes into memory at `self.
  ///  
  /// - Precondition: The underlying pointer is properly aligned for storing
  ///   type `T`.
  ///
  /// - Precondition: `T` is a trivial type.
  ///
  /// - Precondition: The memory is uninitialized, or initialized some
  ///   trivial type `U` such that `T` and `U` are mutually layout
  ///   compatible.
  /// 
  /// - Postcondition: The memory is initialized to raw bytes. If the
  ///   memory is bound to type `U`, then it now contains a value of
  ///   type `U`.
  public func storeRaw<T>(contiguous: T.Type, from source: UnsafeRawPointer,
    count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutableRawPointer.storeRaw with negative count")
    _debugPrecondition(
      UnsafeRawPointer(self) < source
      || source + (count * strideof(T.self)) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.storeRaw non-following overlapping range")

    Builtin.int_memcpy_RawPointer_RawPointer_Int64(
      _rawValue, source._rawValue, (count * strideof(T.self))._value,
      /*alignment:*/ Int32(0)._value,
      /*volatile:*/ false._value)
  }

  /// Read `count` contiguous values from of type `T` from `source`
  /// and store their raw bytes into memory at `self. Memory is
  /// processed from the highest to lowest address.
  ///  
  /// - Precondition: The underlying pointer is properly aligned for storing
  ///   type `T`.
  ///
  /// - Precondition: `T` is a trivial type.
  ///
  /// - Precondition: The memory is uninitialized, or initialized some
  ///   trivial type `U` such that `T` and `U` are mutually layout
  ///   compatible.
  /// 
  /// - Postcondition: The memory is initialized to raw bytes. If the
  ///   memory is bound to type `U`, then it now contains a value of
  ///   type `U`.
  public func storeRawBackward<T>(contiguous: T.Type,
    from source: UnsafeRawPointer,
    count: Int) {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.storeRawBackward with negative count")
    _debugPrecondition(
      source < UnsafeRawPointer(self)
      || source >= UnsafeRawPointer(self) + (count * strideof(T.self)),
      "UnsafeMutableRawPointer.storeRawBackward non-preceding overlapping range; use initialize(from:) instead")

    var destPtr = self + ((count - 1) * strideof(T.self))
    var srcPtr = source + ((count - 1) * strideof(T.self))
    while destPtr >= self {
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        destPtr._rawValue, srcPtr._rawValue, strideof(T.self)._value,
        /*alignment:*/ Int32(0)._value,
        /*volatile:*/ false._value)
      destPtr -= strideof(T.self)
      srcPtr -= strideof(T.self)
    }
  }
%  end # mutable

  //
  // Protocol conformance
  //

  /// The hash value.
  ///
  /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
  ///
  /// - Note: The hash value is not guaranteed to be stable across
  ///   different invocations of the same program.  Do not persist the
  ///   hash value across program runs.
  public var hashValue: Int {
    return Int(Builtin.ptrtoint_Word(_rawValue))
  }

  /// Return `end - self`.
  public func distance(to x: ${Self}) -> Int {
    return x - self
  }

  /// Return `self + n`.
  public func advanced(by n: Int) -> ${Self} {
    return self + n
  }
}

@_transparent
public func == (lhs: ${Self}, rhs: ${Self}) -> Bool {
  return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
}

@_transparent
public func < (lhs: ${Self}, rhs: ${Self}) -> Bool {
  return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
}

@_transparent
public func + (lhs: ${Self}, rhs: Int) -> ${Self} {
  return ${Self}(Builtin.gep_Word(
      lhs._rawValue, rhs._builtinWordValue))
}

@_transparent
public func + (lhs: Int, rhs: ${Self}) -> ${Self} {
  return rhs + lhs
}

@_transparent
public func - (lhs: ${Self}, rhs: Int) -> ${Self} {
  return lhs + -rhs
}

@_transparent
public func - (lhs: ${Self}, rhs: ${Self}) -> Int {
  return
    Int(Builtin.sub_Word(Builtin.ptrtoint_Word(lhs._rawValue),
                         Builtin.ptrtoint_Word(rhs._rawValue)))
}

@_transparent
public func += (lhs: inout ${Self}, rhs: Int) {
  lhs = lhs + rhs
}

@_transparent
public func -= (lhs: inout ${Self}, rhs: Int) {
  lhs = lhs - rhs
}

extension Unsafe${Mutable}RawPointer : CustomDebugStringConvertible {
  /// A textual representation of `self`, suitable for debugging.
  public var debugDescription: String {
    return _rawPointerToString(_rawValue)
  }
}

extension Unsafe${Mutable}RawPointer : CustomReflectable {
  public var customMirror: Mirror {
    let ptrValue = UInt64(
      bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return Mirror(self, children: ["pointerValue": ptrValue])
  }
}

extension Unsafe${Mutable}RawPointer : CustomPlaygroundQuickLookable {
  var summary: String {
    let selfType = "${Self}"
    let ptrValue = UInt64(
      bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return ptrValue == 0
    ? "\(selfType)(nil)"
    : "\(selfType)(0x\(_uint64ToString(ptrValue, radix:16, uppercase:true)))"
  }

  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    return .text(summary)
  }
}

extension OpaquePointer {
  public init(_ from: Unsafe${Mutable}RawPointer) {
    self._rawValue = from._rawValue
  }

  public init?(_ from: Unsafe${Mutable}RawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
}

extension Int {
  public init(bitPattern: Unsafe${Mutable}RawPointer?) {
    if let bitPattern = bitPattern {
      self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))
    } else {
      self = 0
    }
  }
}

extension UInt {
  public init(bitPattern: Unsafe${Mutable}RawPointer?) {
    if let bitPattern = bitPattern {
      self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))
    } else {
      self = 0
    }
  }
}

% end # for mutable

