//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
  def atomicTypes():
    return [
      # Swift                     AtomicStorage              Builtin
      ("UnsafeRawPointer",        "UnsafeRawPointer",        "RawPointer"),
      ("UnsafeMutableRawPointer", "UnsafeMutableRawPointer", "RawPointer"),
      ("UnsafePointer",           "UnsafePointer",           "RawPointer"),
      ("UnsafeMutablePointer",    "UnsafeMutablePointer",    "RawPointer"),
      ("Unmanaged",               "UnsafeMutableRawPointer", "RawPointer"),
    ]

  def nullableAtomicTypes():
    return [
      # Swift                     AtomicStorage                Builtin
      ("UnsafeRawPointer",        "UnsafeRawPointer?",         "RawPointer"),
      ("UnsafeMutableRawPointer", "UnsafeMutableRawPointer?",  "RawPointer"),
      ("UnsafePointer",           "UnsafePointer?",            "RawPointer"),
      ("UnsafeMutablePointer",    "UnsafeMutablePointer?",     "RawPointer"),
      ("Unmanaged",               "UnsafeMutableRawPointer?",  "RawPointer"),
    ]

  def rmwOrderings():
    return [
      # Swift enum case,         llvm name,   failure name
      ('relaxed',                'monotonic', 'monotonic'),
      ('acquiring',              'acquire',   'acquire'),
      ('releasing',              'release',   'monotonic'),
      ('acquiringAndReleasing',  'acqrel',    'acquire'),
      ('sequentiallyConsistent', 'seqcst',    'seqcst'),
    ]

  def loadOrderings():
    return [
      # Swift enum case,         llvm name
      ('relaxed',                'monotonic'),
      ('acquiring',              'acquire'),
      ('sequentiallyConsistent', 'seqcst'),
    ]

  def storeOrderings():
    return [
      # Swift enum case,         llvm name
      ('relaxed',                'monotonic'),
      ('releasing',              'release'),
      ('sequentiallyConsistent', 'seqcst'),
    ]

  def caseStatementForOrdering(ordering):
    if ordering == 'sequentiallyConsistent':
      return "default"
    else:
      return "case .{}".format(ordering)

  # FIXME: Swift should provide intrinsics for arbitrary ordering pairs
  def llvmOrders(rmw, load): # See llvm/Support/AtomicOrdering.h
    def max(rmw, load):
      if load == "acquire":
        if rmw == "monotonic":
          return "acquire"
        if rmw == "release":
          return "acqrel"
      if load == "seqcst":
        return "seqcst"
      return rmw
    return max(rmw, load) + "_" + load
}%

import Swift


% for (swiftType, atomicType, builtinType) in atomicTypes():
@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension ${swiftType}: AtomicProtocol {
  public typealias AtomicStorage = ${atomicType}

  % if swiftType == "Unmanaged":
  @_transparent @_alwaysEmitIntoClient
  internal init(_atomicRawValue raw: Builtin.${builtinType}) {
    self = Unmanaged.fromOpaque(UnsafeRawPointer(raw))
  }

  @_transparent @_alwaysEmitIntoClient
  internal var _atomicRawValue: Builtin.${builtinType} {
    toOpaque()._rawValue
  }
  % else:
  @_transparent @_alwaysEmitIntoClient
  internal init(_atomicRawValue raw: Builtin.${builtinType}) {
    self.init(raw)
  }

  @_transparent @_alwaysEmitIntoClient
  internal var _atomicRawValue: Builtin.${builtinType} {
    self._rawValue
  }
  % end

  @inlinable
  public static func atomicStorage(for value: Self) -> AtomicStorage {
    % if swiftType == "Unmanaged":
    return value.toOpaque()
    % else:
    return value
    % end
  }

  @inlinable
  public static func deinitializeAtomicStorage(
    at pointer: UnsafeMutablePointer<AtomicStorage>
  ) {
    pointer.deinitialize(count: 1)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<AtomicStorage>,
    ordering: AtomicLoadOrdering
  ) -> Self {
    let raw: Builtin.${builtinType}
    switch ordering {
%   for (swiftOrder, llvmOrder) in loadOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      raw = Builtin.atomicload_${llvmOrder}_${builtinType}(
        pointer._atomicRawValue)
%   end
    }
    return Self(_atomicRawValue: raw)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Self,
    at pointer: UnsafeMutablePointer<AtomicStorage>,
    ordering: AtomicStoreOrdering
  ) {
    switch ordering {
%   for (swiftOrder, llvmOrder) in storeOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      Builtin.atomicstore_${llvmOrder}_${builtinType}(
        pointer._rawValue,
        desired._atomicRawValue)
%   end
    }
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Self,
    at pointer: UnsafeMutablePointer<AtomicStorage>,
    ordering: AtomicUpdateOrdering
  ) -> Self {
    let rawResult: Builtin.${builtinType}
    switch ordering {
%   for (swiftOrder, llvmOrder, _) in rmwOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      rawResult = Builtin.atomicrmw_xchg_${llvmOrder}_${builtinType}(
        pointer._rawValue,
        desired._atomicRawValue)
%   end
    }
    return Self(_atomicRawValue: rawResult)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Self,
    desired: Self,
    at pointer: UnsafeMutablePointer<AtomicStorage>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Self) {
    let old: Builtin.${builtinType}
    let won: Builtin.Int1
    switch ordering {
%   for (swiftOrder, llvmOrder, failureOrder) in rmwOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      (old, won) = Builtin.cmpxchg_${llvmOrder}_${failureOrder}_${builtinType}(
        pointer._rawValue,
        expected._atomicRawValue,
        desired._atomicRawValue)
%   end
    }
    return (
      Bool(_builtinBooleanLiteral: won),
      Self(_atomicRawValue: old))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Self,
    desired: Self,
    at pointer: UnsafeMutablePointer<AtomicStorage>,
    ordering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Self) {
    let old: Builtin.${builtinType}
    let won: Builtin.Int1
    switch (ordering, failureOrdering) {
% for (swiftSuccess, llvmSuccess, _) in rmwOrderings():
%   for (swiftFailure, llvmFailure) in loadOrderings():
    case (.${swiftSuccess}, .${swiftFailure}):
      (old, won) = Builtin.cmpxchg_${llvmOrders(llvmSuccess, llvmFailure)}_${builtinType}(
        pointer._rawValue,
        expected._atomicRawValue,
        desired._atomicRawValue)
%   end
% end
    default:
      (old, won) = Builtin.cmpxchg_seqcst_seqcst_${builtinType}(
        pointer._rawValue,
        expected._atomicRawValue,
        desired._atomicRawValue)
    }
    return (
      Bool(_builtinBooleanLiteral: won),
      Self(_atomicRawValue: old))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Self,
    desired: Self,
    at pointer: UnsafeMutablePointer<AtomicStorage>,
    ordering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Self) {
    let old: Builtin.${builtinType}
    let won: Builtin.Int1
    switch (ordering, failureOrdering) {
% for (swiftSuccess, llvmSuccess, _) in rmwOrderings():
%   for (swiftFailure, llvmFailure) in loadOrderings():
    case (.${swiftSuccess}, .${swiftFailure}):
      (old, won) = Builtin.cmpxchg_${llvmOrders(llvmSuccess, llvmFailure)}_weak_${builtinType}(
        pointer._rawValue,
        expected._atomicRawValue,
        desired._atomicRawValue)
%   end
% end
    default:
      (old, won) = Builtin.cmpxchg_seqcst_seqcst_weak_${builtinType}(
        pointer._rawValue,
        expected._atomicRawValue,
        desired._atomicRawValue)
    }
    return (
      Bool(_builtinBooleanLiteral: won),
      Self(_atomicRawValue: old))
  }
}
% end

% for (swiftType, atomicType, builtinType) in nullableAtomicTypes():
@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
extension ${swiftType}: NullableAtomic {
  public typealias NullableAtomicStorage = ${atomicType}

  % if swiftType == "Unmanaged":
  @_transparent @_alwaysEmitIntoClient
  internal init?(_atomicOptionalRawValue raw: Builtin.${builtinType}) {
    // FIXME: This assumes the nil value is represented by all zero bits.
    if Int(Builtin.ptrtoint_Word(raw)) == 0 { return nil }
    self = Unmanaged.fromOpaque(UnsafeRawPointer(raw))
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _atomicOptionalRawValue(
    for value: Self?
  ) -> Builtin.${builtinType} {
    // FIXME: This assumes the nil value is represented by all zero bits.
    guard let value = value else {
      return Builtin.inttoptr_Word(0._builtinWordValue)
    }
    return value.toOpaque()._rawValue
  }
  % else:
  @_transparent @_alwaysEmitIntoClient
  internal init?(_atomicOptionalRawValue raw: Builtin.${builtinType}) {
    // FIXME: This assumes the nil value is represented by all zero bits.
    if Int(Builtin.ptrtoint_Word(raw)) == 0 { return nil }
    self.init(raw)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _atomicOptionalRawValue(
    for value: Self?
  ) -> Builtin.${builtinType} {
    // FIXME: This assumes the nil value is represented by all zero bits.
    guard let value = value else {
      return Builtin.inttoptr_Word(0._builtinWordValue)
    }
    return value._rawValue
  }
  % end

  @inlinable
  public static func nullableAtomicStorage(
    for value: Self?
  ) -> NullableAtomicStorage {
    % if swiftType == "Unmanaged":
    return value?.toOpaque()
    % else:
    return value
    % end
  }

  @inlinable
  public static func deinitializeNullableAtomicStorage(
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>
  ) {
    pointer.deinitialize(count: 1)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicOptionalLoad(
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>,
    ordering: AtomicLoadOrdering
  ) -> Self? {
    let raw: Builtin.${builtinType}
    switch ordering {
%   for (swiftOrder, llvmOrder) in loadOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      raw = Builtin.atomicload_${llvmOrder}_${builtinType}(
        pointer._rawValue)
%   end
    }
    return ${swiftType}(_atomicOptionalRawValue: raw)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicOptionalStore(
    _ desired: Self?,
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>,
    ordering: AtomicStoreOrdering
  ) {
    switch ordering {
%   for (swiftOrder, llvmOrder) in storeOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      Builtin.atomicstore_${llvmOrder}_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: desired))
%   end
    }
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicOptionalExchange(
    _ desired: Self?,
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>,
    ordering: AtomicUpdateOrdering
  ) -> Self? {
    let rawResult: Builtin.${builtinType}
    switch ordering {
%   for (swiftOrder, llvmOrder, _) in rmwOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      rawResult = Builtin.atomicrmw_xchg_${llvmOrder}_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: desired))
%   end
    }
    return Self(_atomicOptionalRawValue: rawResult)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicOptionalCompareExchange(
    expected: Self?,
    desired: Self?,
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Self?) {
    let old: Builtin.${builtinType}
    let won: Builtin.Int1
    switch ordering {
%   for (swiftOrder, llvmOrder, failureOrder) in rmwOrderings():
    ${caseStatementForOrdering(swiftOrder)}:
      (old, won) = Builtin.cmpxchg_${llvmOrder}_${failureOrder}_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: expected),
        Self._atomicOptionalRawValue(for: desired))
%   end
    }
    return (
      Bool(_builtinBooleanLiteral: won),
      Self(_atomicOptionalRawValue: old))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicOptionalCompareExchange(
    expected: Self?,
    desired: Self?,
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>,
    ordering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Self?) {
    let old: Builtin.${builtinType}
    let won: Builtin.Int1
    switch (ordering, failureOrdering) {
% for (swiftSuccess, llvmSuccess, _) in rmwOrderings():
%   for (swiftFailure, llvmFailure) in loadOrderings():
    case (.${swiftSuccess}, .${swiftFailure}):
      (old, won) = Builtin.cmpxchg_${llvmOrders(llvmSuccess, llvmFailure)}_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: expected),
        Self._atomicOptionalRawValue(for: desired))
%   end
% end
    default:
      (old, won) = Builtin.cmpxchg_seqcst_seqcst_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: expected),
        Self._atomicOptionalRawValue(for: desired))
    }
    return (
      Bool(_builtinBooleanLiteral: won),
      Self(_atomicOptionalRawValue: old))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicOptionalWeakCompareExchange(
    expected: Self?,
    desired: Self?,
    at pointer: UnsafeMutablePointer<NullableAtomicStorage>,
    ordering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Self?) {
    let old: Builtin.${builtinType}
    let won: Builtin.Int1
    switch (ordering, failureOrdering) {
% for (swiftSuccess, llvmSuccess, _) in rmwOrderings():
%   for (swiftFailure, llvmFailure) in loadOrderings():
    case (.${swiftSuccess}, .${swiftFailure}):
      (old, won) = Builtin.cmpxchg_${llvmOrders(llvmSuccess, llvmFailure)}_weak_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: expected),
        Self._atomicOptionalRawValue(for: desired))
%   end
% end
    default:
      (old, won) = Builtin.cmpxchg_seqcst_seqcst_weak_${builtinType}(
        pointer._rawValue,
        Self._atomicOptionalRawValue(for: expected),
        Self._atomicOptionalRawValue(for: desired))
    }
    return (
      Bool(_builtinBooleanLiteral: won),
      Self(_atomicOptionalRawValue: old))
  }
}
