//===-- MoveValueInserter.cpp - Insert move_values to test later passes. --===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "move-value-inserter"

#include "swift/SIL/NodeDatastructures.h"
#include "swift/SIL/OwnershipUtils.h"
#include "swift/SIL/SILBuilder.h"
#include "swift/SIL/SILFunction.h"
#include "swift/SIL/SILInstruction.h"
#include "swift/SILOptimizer/PassManager/Transforms.h"

using namespace swift;

namespace {

class Implementation {
  SILFunction *function;
  SILBuilderContext context;
  SmallPtrSet<SILValue, 16> movedValues;

  static bool shouldMoveFromInst(SILInstruction *inst) {
    switch (inst->getKind()) {
    case SILInstructionKind::OpenExistentialRefInst:
    case SILInstructionKind::AllocBoxInst:
    case SILInstructionKind::MoveValueInst:
      return false;
    default:
      return true;
    }
  }

  static bool shouldMoveFromArgument(SILPhiArgument *argument) {
    if (!argument->isPhi()) {
      // Move from owned terminator results.
      return true;
    }
    return visitInnerAdjacentPhis(argument,
                                  [&](auto *argument) { return false; });
  }

  bool shouldMoveValue(SILValue value) {
    if (!movedValues.insert(value).second) {
      // If it's already moved, don't move it.
      return false;
    }
    if (value->getOwnershipKind() != OwnershipKind::Owned) {
      // Non-owned values can't be moved.
      return false;
    }
    auto *inst = value->getDefiningInstruction();
    if (inst && !shouldMoveFromInst(inst)) {
      return false;
    }
    auto *argument = dyn_cast<SILPhiArgument>(value);
    if (argument && !shouldMoveFromArgument(argument)) {
      return false;
    }
    return true;
  }

  MoveValueInst *moveValue(SILValue value, SILInstruction *insertionPoint) {
    SILBuilderWithScope builder(insertionPoint, context);
    auto loc = CleanupLocation(
        RegularLocation::getAutoGeneratedLocation(insertionPoint->getLoc()));
    auto *mvi =
        builder.createMoveValue(loc, value, /*isLexical=*/value->isLexical());
    return mvi;
  }

  bool maybeMoveProducedValue(SILValue value, SILInstruction *insertionPoint) {
    if (!shouldMoveValue(value)) {
      return false;
    }
    if (value->isLexical()) {
      return false;
    }
    auto *mvi = moveValue(value, insertionPoint);
    value->replaceAllUsesWith(mvi);
    mvi->getOperandRef().set(value);
    movedValues.insert(mvi);
    return true;
  }

  bool maybeMoveConsumedValue(Operand &operand,
                              SILInstruction *insertionPoint) {
    auto value = operand.get();
    if (!shouldMoveValue(value)) {
      return false;
    }
    if (operand.getOperandOwnership() != OperandOwnership::DestroyingConsume) {
      return false;
    }
    auto *mvi = moveValue(value, insertionPoint);
    operand.set(mvi);
    movedValues.insert(mvi);
    return true;
  }

public:
  Implementation(SILFunction *function)
      : function(function), context(function->getModule()) {}

  bool run() {
    bool changed = false;
    for (auto &block : *function) {
      for (auto *argument : block.getArguments()) {
        changed |= maybeMoveProducedValue(argument, &block.front());
      }
      SmallVector<SILInstruction *, 32> instructions;
      for (auto &instruction : block) {
        instructions.push_back(&instruction);
      }
      for (auto *instructionPtr : instructions) {
        auto &instruction = *instructionPtr;
        for (auto result : instruction.getResults()) {
          changed |=
              maybeMoveProducedValue(result, instruction.getNextInstruction());
        }
        for (auto &operand : instruction.getAllOperands()) {
          changed |= maybeMoveConsumedValue(operand, &instruction);
        }
      }
    }
    return changed;
  }
};

class MoveValueInserter : public SILFunctionTransform {

  void run() override {
    SILFunction *f = getFunction();
    if (!f->hasOwnership()) {
      return;
    }
    Implementation impl(f);
    if (impl.run())
      invalidateAnalysis(SILAnalysis::InvalidationKind::Instructions);
  }
};

} // end anonymous namespace

SILTransform *swift::createMoveValueInserter() {
  return new MoveValueInserter();
}
