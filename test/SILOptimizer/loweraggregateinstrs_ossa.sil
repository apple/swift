// RUN: %target-sil-opt -enable-sil-verify-all %s -lower-aggregate-instrs | %FileCheck %s

// This file makes sure that given the current code-size metric we properly
// expand operations for small structs and not for large structs in a consistent
// way for all operations we expand.

sil_stage canonical

import Swift
import Builtin

class C1 {
  var data : Builtin.Int64
  init()
}

class C2 {
  var data : Builtin.FPIEEE32
  init()
}

class C3 {
  var data : Builtin.FPIEEE64
  init()
}

struct S2 {
  var cls1 : C1
  var cls2 : C2
  var trivial : Builtin.FPIEEE32
}

struct S {
  var trivial : Builtin.Int64
  var cls : C3
  var inner_struct : S2
}

enum E {
  case NoElement
  case TrivialElement(Builtin.Int64)
  case ReferenceElement(C1)
  case StructNonTrivialElt(S)
  case TupleNonTrivialElt((Builtin.Int64, S, C3))
}

// This struct is larger than our current code-size limit (> 6 leaf nodes).
struct LargeStruct {
  var trivial1 : Builtin.Int64
  var cls : S
  var trivial2 : Builtin.Int64
  var trivial3 : Builtin.Int64
}

///////////
// Tests //
///////////

// This test makes sure that we /do not/ expand retain_value, release_value and
// promote copy_addr/destroy_value to non-expanded retain_value, release_value.
// CHECK-LABEL: sil [ossa] @large_struct_test : $@convention(thin) (@owned LargeStruct, @in LargeStruct)
// CHECK: bb0([[ARG0:%.*]] : @owned $LargeStruct, [[ARG1:%.*]] : $*LargeStruct):
// CHECK:   begin_borrow [[ARG0]]
// CHECK:   end_borrow
// CHECK:   destroy_value [[ARG0]]
// CHECK:   [[ALLOC_STACK:%.*]] = alloc_stack $LargeStruct
// CHECK:   [[LOADED_ARG1:%.*]] = load [copy] [[ARG1]]
// CHECK:   store [[LOADED_ARG1]] to [init] [[ALLOC_STACK]]
// CHECK:   [[LOADED_ARG1:%.*]] = load [take] [[ARG1]]
// CHECK:   destroy_value [[LOADED_ARG1]] : $LargeStruct
// CHECK:   dealloc_stack [[ALLOC_STACK]]
// CHECK: } // end sil function 'large_struct_test'

sil [ossa] @large_struct_test : $@convention(thin) (@owned LargeStruct, @in LargeStruct) -> () {
bb0(%0 : @owned $LargeStruct, %1 : $*LargeStruct):
  %2 = begin_borrow %0 : $LargeStruct
  end_borrow %2 : $LargeStruct
  destroy_value %0 : $LargeStruct
  %3 = alloc_stack $LargeStruct
  copy_addr %1 to [initialization] %3 : $*LargeStruct
  destroy_addr %1 : $*LargeStruct
  destroy_addr %3 : $*LargeStruct
  dealloc_stack %3 : $*LargeStruct
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @small_struct_test : $@convention(thin) (@owned S2, @in S2)
// CHECK: bb0([[ARG0:%.*]] : @owned $S2, [[ARG1:%.*]] : $*S2):
// CHECK-NEXT:   destroy_value [[ARG0]]
// CHECK-NEXT:   [[ALLOC_STACK:%.*]] = alloc_stack $S2
// CHECK-NEXT:   [[LOADED_ARG1:%.*]] = load [copy] [[ARG1]]
// CHECK-NEXT:   store [[LOADED_ARG1]] to [init] [[ALLOC_STACK]]

// CHECK-NEXT:   [[LOADED_ARG1:%.*]] = load [take] [[ARG1]] : $*S2
// CHECK-NEXT:   ([[A:%.*]], [[B:%.*]], [[C:%.*]]) = destructure_struct [[LOADED_ARG1]]
// CHECK-NEXT:   destroy_value [[A]] : $C1
// CHECK-NEXT:   destroy_value [[B]] : $C2

// CHECK-NEXT:   [[LOADED_STACK:%.*]] = load [take] [[ALLOC_STACK]] : $*S2
// CHECK-NEXT:   ([[A:%.*]], [[B:%.*]], [[C:%.*]]) = destructure_struct [[LOADED_STACK]]
// CHECK-NEXT:   destroy_value [[A]] : $C1
// CHECK-NEXT:   destroy_value [[B]] : $C2

// CHECK-NEXT:   dealloc_stack [[ALLOC_STACK]]
// CHECK-NEXT:   tuple
// CHECK-NEXT:   return
// CHECK: } // end sil function 'small_struct_test'
sil [ossa] @small_struct_test : $@convention(thin) (@owned S2, @in S2) -> () {
bb0(%0 : @owned $S2, %1 : $*S2):
  destroy_value %0 : $S2
  %3 = alloc_stack $S2
  copy_addr %1 to [initialization] %3 : $*S2
  destroy_addr %1 : $*S2
  destroy_addr %3 : $*S2
  dealloc_stack %3 : $*S2
  %9999 = tuple()
  return %9999 : $()
}
