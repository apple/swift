// RUN: %target-sil-opt -module-name moveonly_addresschecker -sil-move-only-address-checker -enable-experimental-feature MoveOnlyClasses -enable-experimental-feature MoveOnlyPartialConsumption -enable-sil-verify-all %s | %FileCheck %s

sil_stage raw

import Swift
import Builtin

public class CopyableKlass {}

@_moveOnly
public final class Klass {
    var intField: Int
    var k: Klass
    init()
}

sil @get_klass : $@convention(thin) () -> @owned Klass
sil @nonConsumingUseKlass : $@convention(thin) (@guaranteed Klass) -> ()

sil @copyableClassConsume : $@convention(thin) (@owned CopyableKlass) -> () // user: %24
sil @copyableClassUseMoveOnlyWithoutEscaping : $@convention(thin) (@guaranteed CopyableKlass) -> () // user: %16

@_moveOnly
public struct NonTrivialStruct {
    var k = Klass()
    var copyableK = CopyableKlass()
    var nonTrivialStruct2 = NonTrivialStruct2()
}

sil @useNonTrivialStruct : $@convention(thin) (@guaranteed NonTrivialStruct) -> ()
sil @getNonTrivialStruct : $@convention(thin) () -> @owned NonTrivialStruct
sil @consumeNonTrivialStructAddr : $@convention(thin) (@in NonTrivialStruct) -> ()
sil @consumeNonTrivialStruct : $@convention(thin) (@owned NonTrivialStruct) -> ()

@_moveOnly
public struct NonTrivialStructPair {
    var lhs: NonTrivialStruct
    var rhs: NonTrivialStruct
}

@_moveOnly
public struct NonTrivialStruct2 {
    var copyableKlass = CopyableKlass()
}

sil @useNonTrivialStruct2 : $@convention(thin) (@guaranteed NonTrivialStruct2) -> ()

@_moveOnly struct MyBufferView<T> {
  var ptr: UnsafeBufferPointer<T>
}

final class ClassContainingMoveOnly {
  var value = NonTrivialStruct()
}

struct SingleTrivialFieldAndDeinit: ~Copyable {
    var value: Builtin.IntLiteral

    consuming func finalize()

    deinit
}

sil @getSingleTrivialFieldAndDeinit : $@convention(thin) () -> @owned SingleTrivialFieldAndDeinit
sil @finalizeSingleTrivialFieldAndDeinit : $@convention(thin) (@owned SingleTrivialFieldAndDeinit) -> ()

@_hasStorage @_hasInitialValue var varGlobal: NonTrivialStruct { get set }
@_hasStorage @_hasInitialValue let letGlobal: NonTrivialStruct { get }
sil_global hidden @$s23moveonly_addresschecker9varGlobalAA16NonTrivialStructVvp : $NonTrivialStruct
sil_global hidden [let] @$s23moveonly_addresschecker9letGlobalAA16NonTrivialStructVvp : $NonTrivialStruct

///////////
// Tests //
///////////


// CHECK-LABEL: sil [ossa] @simpleInitReturnMoveOnlyFieldMultiBlock : $@convention(thin) (@owned NonTrivialStruct) -> @owned Klass {
// CHECK: bb0([[ARG:%.*]] : @owned $NonTrivialStruct):
// CHECK-NEXT:   [[ALLOC_STACK:%.*]] = alloc_stack [lexical]
// CHECK-NEXT:   store [[ARG]] to [init] [[ALLOC_STACK]]
// CHECK-NEXT:   cond_br undef, bb1, bb2
//
// CHECK: bb1:
// CHECK-NEXT:   [[GEP:%.*]] = struct_element_addr [[ALLOC_STACK]]
// CHECK-NEXT:   [[RESULT:%.*]] = load [take] [[GEP]]
// CHECK-NEXT:   br bb3([[RESULT]] :
//
// CHECK: bb2:
// CHECK-NEXT:   [[GEP:%.*]] = struct_element_addr [[ALLOC_STACK]]
// CHECK-NEXT:   [[RESULT:%.*]] = load [take] [[GEP]]
// CHECK-NEXT:   br bb3([[RESULT]] :

// CHECK: bb3([[RESULT:%.*]] :
// CHECK-NEXT:   [[GEP_1:%.*]] = struct_element_addr [[ALLOC_STACK]] : $*NonTrivialStruct, #NonTrivialStruct.copyableK
// CHECK-NEXT:   [[GEP_2:%.*]] = struct_element_addr [[ALLOC_STACK]] : $*NonTrivialStruct, #NonTrivialStruct.nonTrivialStruct2
// CHECK-NEXT:   destroy_addr [[GEP_1]]
// CHECK-NEXT:   destroy_addr [[GEP_2]]
// CHECK-NEXT:   dealloc_stack [[ALLOC_STACK]]
// CHECK-NEXT:   return [[RESULT]]
// CHECK: } // end sil function 'simpleInitReturnMoveOnlyFieldMultiBlock'
sil [ossa] @simpleInitReturnMoveOnlyFieldMultiBlock : $@convention(thin) (@owned NonTrivialStruct) -> @owned Klass {
bb0(%0 : @owned $NonTrivialStruct):
  %1 = alloc_stack [lexical] $NonTrivialStruct
  %2 = mark_must_check [consumable_and_assignable] %1 : $*NonTrivialStruct
  store %0 to [init] %2 : $*NonTrivialStruct
  cond_br undef, bb1, bb2

bb1:
  %3a = struct_element_addr %2 : $*NonTrivialStruct, #NonTrivialStruct.k
  %3 = load [copy] %3a : $*Klass
  br bb3(%3 : $Klass)

bb2:
  %4a = struct_element_addr %2 : $*NonTrivialStruct, #NonTrivialStruct.k
  %4 = load [copy] %4a : $*Klass
  br bb3(%4 : $Klass)

bb3(%5 : @owned $Klass):
  destroy_addr %2 : $*NonTrivialStruct
  dealloc_stack %1 : $*NonTrivialStruct
  return %5 : $Klass
}

