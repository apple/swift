//===--- NumericParsing.swift.gyb -----------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// -*- swift -*-
// RUN: %empty-directory(%t)
// RUN: %gyb -DCMAKE_SIZEOF_VOID_P=%target-ptrsize %s -o %t/NumericParsing.swift
// RUN: %line-directive %t/NumericParsing.swift -- %target-build-swift %t/NumericParsing.swift -o %t/a.out
// RUN: %target-codesign %t/a.out
// RUN: %line-directive %t/NumericParsing.swift -- %target-run %t/a.out
// REQUIRES: executable_test
%{
from __future__ import division
from SwiftIntTypes import all_integer_types

word_bits = int(CMAKE_SIZEOF_VOID_P)

def maskOfWidth(n):
  return (1 << n) - 1

# The maximal legal radix
max_radix = ord('z') - ord('a') + 1 + 10

# Test a few important radices + an odd one
radices_to_test = [2, 10, 16, 8, 11, max_radix]

# How many values to test in each radix?  A nice prime number of course.
number_of_values = 23
}%

import StdlibUnittest


var tests = TestSuite("NumericParsing")

% for int_type in all_integer_types(word_bits):
%   for string_type in [ "String", "Substring" ]:
%     for radix in radices_to_test:
%       Self = int_type.stdlib_name
%       maxValue = maskOfWidth((int_type.bits - 1) if int_type.is_signed else int_type.bits)
%       minValue = -maxValue - 1 if int_type.is_signed else 0
%
%       def inRadix(n, zero='0'):
%         """
%         Represent the int n in the given radix.
%         Note: the second parameter, zero, is not for user consumption.
%         """
%         if n < 0:
%           return '-' + inRadix(-n, '')
%         elif n == 0:
%           return zero
%         else:
%           r = n % radix
%           digit = chr((ord('0') + r) if r < 10 else (ord('a') + r - 10))
%           return inRadix(int(n // radix), '') + digit
%
%       def expectResult(result, input):
%         input = '\"' + input + '\"'
%         if string_type == "Substring": input = "Substring(" + input + ")"
%         return "expectEqual(" + str(result) + ", " \
%           + Self + "(" + input + ", radix: " + str(radix) + "))"
%
%       max_digit = inRadix(radix-1)

tests.test("${Self}/${string_type}/base${radix}/success") {
  //===--- Important cases ------------------------------------------------===//
  // Basic sanity check
  ${expectResult(0, "0")}
  ${expectResult(123, inRadix(123))}

  // Leading zeroes
  ${expectResult(37, "0" + inRadix(37))}
  ${expectResult(42, "00" + inRadix(42))}
  ${expectResult(0, "000")}

  // Leading '+'
  ${expectResult(0, "+0")}
  ${expectResult(14, "+" + inRadix(14))}
  ${expectResult(23, "+0" + inRadix(23))}

  // Negative numbers
  ${expectResult(-128 if int_type.is_signed else "nil", inRadix(-128))}
  ${expectResult(-6 if int_type.is_signed else "nil", "-0" + inRadix(6))}
  ${expectResult(0, "-0")} // Must be valid even for unsigned types
  ${expectResult(0, "-00")}

  % if radix > 10:
  // Letters uppercase/lowercase
  ${expectResult(radix - 1, max_digit.lower())}
  ${expectResult(radix - 1, max_digit.upper())}
  % two_letter_val = 10*radix + radix-1
  % two_letter_result = two_letter_val if two_letter_val <= maxValue else "nil"
  ${expectResult(two_letter_result, "A" + max_digit.lower())}
  %end

  // Extrema
  ${expectResult(minValue, inRadix(minValue))}
  ${expectResult(maxValue, inRadix(maxValue))}
  ${expectResult("nil", inRadix(minValue-1))}
  ${expectResult("nil", inRadix(maxValue+1))}

  //===--- Boundary cases -------------------------------------------------===//

  % if string_type == "String":
  %   # Fast path boundary cases
  %   if radix == 10:
  // Base 10 fast path, 4-digit chunk boundaries
  ${expectResult("0_0000", "00000")} // 2 chunks, both zero
  ${expectResult("0_0000_0000", "000000000")} // 3 chunks, all zero
  %     if maxValue >= 10000:
  ${expectResult("9999", "9999")} // 1 chunk, max value
  ${expectResult("0_9999", "09999")} // 2 chunks, leading chunk zero
  ${expectResult("1_0000", "10000")} // 2 chunks, trailing chunk zero
  %     end
  %     if maxValue >= 100000000:
  ${expectResult("9999_9999", "99999999")} // 2 chunks, max value
  ${expectResult("0_9999_9999", "099999999")} // 3 chunks, leading chunk zero
  ${expectResult("1_0000_0000", "100000000")} // 3 chunks, trailing chunks zero
  %     end
  %   elif radix == 2:
  // Base 2 fast path, 8-digit chunk boundaries
  ${expectResult("0b0_0000_0000", "000000000")} // 2 chunks, both zero
  %     if maxValue >= 0b100000000:
  ${expectResult("0b1111_1111", "11111111")} // 1 chunk, max value
  ${expectResult("0b0_1111_1111", "011111111")} // 2 chunks, leading chunk zero
  ${expectResult("0b1_0000_0000", "100000000")} // 2 chunks, trailing chunk zero
  %     end
  %   elif radix == 16:
  // Base 16 fast path, 8-digit chunk boundaries
  ${expectResult("0x0_0000_000", "000000000")} // 2 chunks, both zero
  %     if maxValue >= 0x100000000:
  ${expectResult("0xffff_ffff", "ffffffff")} // 1 chunk, max value
  ${expectResult("0x0_ffff_ffff", "0ffffffff")} // 2 chunks, leading chunk zero
  ${expectResult("0x1_0000_0000", "100000000")} // 2 chunks, trailing chunk zero
  %     end
  %   end

  %   small_max_count = 15 if word_bits == 64 else 10
  // Every length small value
  %   for n in range(1, small_max_count+1):
  %     value = (radix ** n) - 1
  %     result = value if value <= maxValue else "nil"
  ${expectResult(result, n * max_digit)}
  %   end
  % end

  //===--- Normal values --------------------------------------------------===//

  // Numbers through range
  % required_values = [minValue, 0, maxValue]
  % range_value_count =  (number_of_values - len(required_values))
  % for n in required_values + list(range(
  %   minValue + 1, maxValue - 1,
  %   int((maxValue - minValue - 2) // range_value_count))):
  %   prefix = '+' if n > 0 and n % 2 == 0 else '' # leading '+'
  %   text = inRadix(n)
  ${expectResult(n, prefix + text)}
  %   if text != text.upper():
  ${expectResult(n, prefix + text.upper())}
  %   end
  % end
}

tests.test("${Self}/${string_type}/base${radix}/failures") {
  // Too short
  ${expectResult("nil", "")}
  ${expectResult("nil", "+")}
  ${expectResult("nil", "-")}

  // Multiple signs
  ${expectResult("nil", "--1")}
  ${expectResult("nil", "++0")}
  ${expectResult("nil", "-+1")}
  ${expectResult("nil", "+-0")}

  // UInt64 boundaries
  ${expectResult("nil", inRadix(2**64))}
  ${expectResult("nil", "-" + inRadix(2**64))}
  ${expectResult("nil", "-" + inRadix(2**63 + 1))}
  ${expectResult("nil", "-" + inRadix(2**64 - 1))}

  // Invalid characters
  // Test several important boundary characters at different positions
  % invalid_chars = [
  %  ' ', # Whitespace
  %  '*', ',', '.', # Above/below sign characters
  %  '/', ':', '@', '[', '`', '{', # Above/below digit ranges
  %  "\\u{1d7ff}", # Non-ASCII digit (MATHEMATICAL MONOSPACE DIGIT NINE)
  %  "\\u{00}", "\\u{7f}", # UTF-8 1-byte (ASCII) limits
  %  "\\u{80}", "\\u{7ff}", # UTF-8 2-byte limits
  %  "\\u{800}", "\\u{ffff}", # UTF-8 3-byte limits
  %  "\\u{10000}", "\\u{10ffff}", # UTF-8 4-byte limits
  % ]
  % invalid_chars = map(lambda c: c.encode('utf8') if isinstance(c, unicode) else c, invalid_chars)
  % if radix <= 10:
  %  above_max_digit = chr(ord('0') + radix)
  %  invalid_chars.extend([ above_max_digit, 'a', 'z', 'A', 'Z' ])
  % else:
  %  above_max_digit = chr(ord('a') + (radix - 10))
  %  invalid_chars.extend([ above_max_digit, above_max_digit.upper() ])
  % end
  % for invalid_char in invalid_chars:
  // "${invalid_char}"
  ${expectResult("nil", invalid_char)}
  ${expectResult("nil", "-" + invalid_char)}
  ${expectResult("nil", "1" + invalid_char)}
  ${expectResult("nil", invalid_char + "1")}
  ${expectResult("nil", invalid_char + "-1")}
  % end
}

%     end
%   end

tests.test("${Self}/implicitRadix") {
  expectEqual(123, ${Self}("123"))
}

tests.test("${Self}/radixTooLow") {
  _ = ${Self}("0", radix: 2)
  expectCrashLater()
  _ = ${Self}("0", radix: 1)
}

tests.test("${Self}/radixTooHigh") {
  let maxRadix = ${ord('z') - ord('a') + 1 + 10}
  _ = ${Self}("0", radix: maxRadix)
  expectCrashLater()
  _ = ${Self}("0", radix: maxRadix + 1)
}

% end

tests.test("FixedWidthInteger/maxUInt64") {
  func f<T : FixedWidthInteger>(_ x: T) -> String {
    return String(x, radix: 16)
  }
  let x = f(UInt64.max)
  let y = String(UInt64.max, radix: 16)
  expectEqual(x, y)
}

% for Self in 'Float', 'Double', 'Float80':

% if Self == 'Float80':
#if !os(Windows) && (arch(i386) || arch(x86_64))
% end

tests.test("${Self}/Basics") {
% if Self != 'Float80': # Inf/NaN are not defined for Float80
  expectEqual(.infinity, ${Self}("inf"))
  expectEqual(.infinity, ${Self}("Inf"))
  expectEqual(-(.infinity), ${Self}("-inf"))
  expectEqual(-(.infinity), ${Self}("-Inf"))
  expectEqual(String(${Self}.nan), String(${Self}("nan")!))
  expectEqual(String(${Self}.nan), String(${Self}("NaN")!))

// sNaN cannot be fully supported on i386.
#if !arch(i386)
  expectTrue(${Self}("sNaN")!.isSignalingNaN)
  expectTrue(${Self}("SNAN")!.isSignalingNaN)
  expectTrue(${Self}("+snan")!.isSignalingNaN)
  expectTrue(${Self}("-SnAn")!.isSignalingNaN)
#endif
% end

  expectEqual(-0.0, ${Self}("-0"))
  expectEqual(-0.0, ${Self}("-0.0"))
  expectEqual(0.0, ${Self}("0"))
  expectEqual(0.0, ${Self}("0.0"))
  expectEqual(64206, ${Self}("0xFACE")) // Yes, strtoXXX supports hex.

  // Check that we can round-trip the string representation of 2^100,
  // which requires an exponent to express...
  let large =
    repeatElement(1024 as ${Self}, count: 10).reduce(1, *)
  let largeText = String(large)
  expectEqual(largeText, String(${Self}(largeText)!))

  // ...ditto for its inverse.
  let smallText = String(1 / large)
  expectEqual(smallText, String(${Self}(smallText)!))

  // Cases that should fail to parse
  expectNil(${Self}(""))       // EMPTY
  expectNil(${Self}("0FACE"))  // Hex characters without 0x
  expectNil(${Self}("99x"))
  expectNil(${Self}(" 0"))  // Leading whitespace
  expectNil(${Self}("0 "))  // Trailing whitespace
  expectNil(${Self}("\u{1D7FF}"))  // MATHEMATICAL MONOSPACE DIGIT NINE

  // Values that are too large/small:
  // * Early versions of Swift returned `nil` for e.g., 1e99999 or 1e-99999
  // * After 5.3, large/small values return .infinity or zero, respectively
  // These are tested in NumericParsing2.swift.gyb
}

% if Self == 'Float80':
#endif
% end

% end
runAllTests()
