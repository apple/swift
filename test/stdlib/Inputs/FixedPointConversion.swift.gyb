% # FIXME(integers): add tests that perform the same checks in generic code.
%
% from SwiftIntTypes import all_integer_types, int_max
% from SwiftFloatingPointTypes import all_floating_point_types
% from decimal import Decimal
%
% test_suites = []
%
% word_bits = int(target_ptrsize)
% for self_ty in all_integer_types(word_bits):
%   Self = self_ty.stdlib_name
%   selfMax = self_ty.max
%   selfMin = self_ty.min
%
%   test_suite = 'FixedPointConversion_' + configuration + '_To' + Self
%   test_suites.append(test_suite)
%
//===----------------------------------------------------------------------===//
// BEGIN ${test_suite}.swift
//===----------------------------------------------------------------------===//

import StdlibUnittest

func register${test_suite}() {

  let ${test_suite} = TestSuite("${test_suite}")

%   # Test conversion behaviors for all integer types.
%   for other_ty in all_integer_types(word_bits):
%     Other = other_ty.stdlib_name
%     otherMax = other_ty.max
%     otherMin = other_ty.min
%
  //===--------------------------------------------------------------------===//
  // ${Other}
  //===--------------------------------------------------------------------===//

%     testValues = [
%       selfMin,
%       selfMax,
%       selfMin - 1,
%       selfMax + 1,
%       otherMin,
%       otherMax
%     ]
%     for testValue in testValues:
%       testLiteralValue = str(testValue)
%       if otherMin <= testValue <= otherMax:
%         if selfMin <= testValue <= selfMax:
  ${test_suite}.test("From${Other}(${testLiteralValue})_NeverTraps") {
    let input = get${Other}(${testLiteralValue})
    let actual = ${Self}(input)
    expectEqual(${testLiteralValue}, actual)
  }

  ${test_suite}.test("From${Other}(${testLiteralValue})_NeverFails") {
    let input = get${Other}(${testLiteralValue})
    let actual = ${Self}(exactly: input)
    expectEqual(${testLiteralValue}, actual)
  }

%         else:
  ${test_suite}.test("From${Other}(${testLiteralValue})_AlwaysTraps") {
    let input = get${Other}(${testLiteralValue})
    expectCrash {
      let actual = ${Self}(input)
      _blackHole(actual)
    }
  }

  ${test_suite}.test("From${Other}(${testLiteralValue})_AlwaysFails") {
    let input = get${Other}(${testLiteralValue})
    let actual = ${Self}(exactly: input)
    expectNil(actual)
  }

%         end # if
%       end # if
%     end # for
%   end # for
%
%   # Test conversion behaviors for all floating-point types.
%   for other_type in all_floating_point_types():
%     Other = "Float" + str(other_type.bits)
%     otherMax = int_max(bits=other_type.explicit_significand_bits, signed=False)
%     otherMin = -otherMax
%
  //===--------------------------------------------------------------------===//
  // ${Other}
  //===--------------------------------------------------------------------===//

%     if Other == 'Float16':
#if !((os(macOS) || targetEnvironment(macCatalyst)) && arch(x86_64))
if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {

%     elif Other == 'Float80':
#if !(os(Windows) || os(Android)) && (arch(i386) || arch(x86_64))

%     end # if
%
%     testValues = [
%       Decimal(selfMin),
%       Decimal(selfMax),
%       Decimal(selfMin - 1),
%       Decimal(selfMax + 1),
%       Decimal(otherMin),
%       Decimal(otherMax),
%       Decimal('0.0'),
%       Decimal('-0.0'),
%       Decimal('0.1'),
%       Decimal('-0.1'),
%       Decimal('-123.45')
%     ]
%     for testValue in testValues:
%       testLiteralValue = str(testValue)
%       if otherMin <= testValue <= otherMax:
%         if (selfMin - 1) < testValue < (selfMax + 1):
  ${test_suite}.test("From${Other}(${testLiteralValue})_NeverTraps") {
    let input = get${Other}(${testLiteralValue})
    let actual = ${Self}(input)
    expectEqual(${str(int(testValue))}, actual)
  }

%         else:
  ${test_suite}.test("From${Other}(${testLiteralValue})_AlwaysTraps") {
    let input = get${Other}(${testLiteralValue})
    expectCrash {
      let actual = ${Self}(input)
      _blackHole(actual)
    }
  }

%         end # if
%
%         if (selfMin <= testValue <= selfMax) and (testValue % 1).is_zero():
  ${test_suite}.test("From${Other}(${testLiteralValue})_NeverFails") {
    let input = get${Other}(${testLiteralValue})
    let actual = ${Self}(exactly: input)
    expectEqual(${str(int(testValue))}, actual)
  }

%         else:
  ${test_suite}.test("From${Other}(${testLiteralValue})_AlwaysFails") {
    let input = get${Other}(${testLiteralValue})
    let actual = ${Self}(exactly: input)
    expectNil(actual)
  }

%         end # if
%       end # if
%     end # for
%
%     for testExpression in ['-.infinity', '.infinity', '-.nan', '.nan']:
  ${test_suite}.test("From${Other}(${testExpression})_AlwaysTraps") {
    let input = get${Other}(${testExpression})
    expectCrash {
      let actual = ${Self}(input)
      _blackHole(actual)
    }
  }

  ${test_suite}.test("From${Other}(${testExpression})_AlwaysFails") {
    let input = get${Other}(${testExpression})
    let actual = ${Self}(exactly: input)
    expectNil(actual)
  }

%     end # for
%
%     if Other == 'Float16':
}
#endif // Float16

%     elif Other == 'Float80':
#endif // Float80

%     end # if
%
%   end # for
} // func

% end # for
%
//===----------------------------------------------------------------------===//
// BEGIN main.swift
//===----------------------------------------------------------------------===//

import StdlibUnittest

% for test_suite in test_suites:
register${test_suite}()
% end # for

runAllTests()
