// RUN: %empty-directory(%t)
// RUN: %gyb -DCMAKE_SIZEOF_VOID_P=%target-ptrsize %s -o %t/UnsafeAtomicInitializers.swift
// RUN: %line-directive %t/UnsafeAtomicInitializers.swift -- %target-swift-frontend -typecheck -verify %t/UnsafeAtomicInitializers.swift

%{
  types = [
    # id        type     storage   initial
    ("Int",     "Int",    "Int",    "0"),
    ("Int64",   "Int64",  "Int64",  "0"),
    ("Int32",   "Int32",  "Int32",  "0"),
    ("Int16",   "Int16",  "Int16",  "0"),
    ("Int8",    "Int8",   "Int8",   "0"),
    ("UInt",    "UInt",   "UInt",   "0"),
    ("UInt64",  "UInt64", "UInt64", "0"),
    ("UInt32",  "UInt32", "UInt32", "0"),
    ("UInt16",  "UInt16", "UInt16", "0"),
    ("UInt8",   "UInt8",  "UInt8",  "0"),

    # id             type                          storage                      initial
    ("URP",          "UnsafeRawPointer",           "UnsafeRawPointer",          "UnsafeRawPointer(UnsafeMutableRawPointer.allocate(byteCount: 8, alignment: 8))"),
    ("UP",           "UnsafePointer<Bar>",         "UnsafePointer<Bar>",        "UnsafePointer(UnsafeMutablePointer<Bar>.allocate(capacity: 1))"),
    ("UMRP",         "UnsafeMutableRawPointer",    "UnsafeMutableRawPointer",   ".allocate(byteCount: 8, alignment: 8)"),
    ("UMP",          "UnsafeMutablePointer<Bar>",  "UnsafeMutablePointer<Bar>", ".allocate(capacity: 1)"),
    ("Unmanaged",    "Unmanaged<Foo>",             "UnsafeMutableRawPointer",   "Unmanaged.passRetained(Foo()).toOpaque()"),

    # id             type                                   storage                                initial
    ("URPOpt",       "Optional<UnsafeRawPointer>",          "Optional<UnsafeRawPointer>",          "nil"),
    ("UPOpt",        "Optional<UnsafePointer<Bar>>",        "Optional<UnsafePointer<Bar>>",        "nil"),
    ("UMRPOpt",      "Optional<UnsafeMutableRawPointer>",   "Optional<UnsafeMutableRawPointer>",   "nil"),
    ("UMPOpt",       "Optional<UnsafeMutablePointer<Bar>>", "Optional<UnsafeMutablePointer<Bar>>", "nil"),
    ("UnmanagedOpt", "Optional<Unmanaged<Foo>>",            "Optional<UnsafeMutableRawPointer>",   "nil"),
  ]
}%

import Atomics

class Foo {
  var value = 0
}
struct Bar {
  var value = 0
}

% for (id, type, storage, initial) in types:
@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_${id}() -> UnsafeAtomicPointer<${type}> {
  var storage: ${storage} = ${initial}
  let atomic = UnsafeAtomicPointer<${type}>(at: &storage) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from '${storage}' to 'UnsafeMutablePointer<${type}.AtomicStorage>' (aka 'UnsafeMutablePointer<${storage}>') produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}
% end

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_UnsafeAtomicLazyReference() -> UnsafeAtomicLazyReference<Foo> {
  var value: Foo? = nil
  let atomic = UnsafeAtomicLazyReference(at: &value) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'Foo?' to 'UnsafeMutablePointer<Foo?>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
class BrokenAtomicCounter { // THIS IS BROKEN; DO NOT USE
  private var _storage = 0
  private var _value: UnsafeAtomicPointer<Int>?

  init() {
    // This escapes the ephemeral pointer generated by the inout expression,
    // so it leads to undefined behavior when the pointer gets dereferenced
    // in the atomic operations below. DO NOT DO THIS.
    _value = UnsafeAtomicPointer(at: &_storage) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
    // expected-note@-1 {{implicit argument conversion from 'Int' to 'UnsafeMutablePointer<Int.AtomicStorage>' (aka 'UnsafeMutablePointer<Int>') produces a pointer valid only for the duration of the call to 'init(at:)'}}
    // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  }

  func increment() {
    _value!.wrappingIncrement(by: 1, ordering: .relaxed)
  }

  func get() -> Int {
    _value!.load(ordering: .relaxed)
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
struct AtomicCounter {
  class Buffer: ManagedBuffer<Int.AtomicStorage, Void> {
    deinit {
      withUnsafeMutablePointerToHeader { header in
        Int.deinitializeAtomicStorage(at: header)
      }
    }
  }

  let buffer: Buffer

  init() {
    buffer = Buffer.create(minimumCapacity: 0) { _ in
      Int.atomicStorage(for: 0)
    } as! Buffer
  }

  private func _withAtomicPointer<R>(
    _ body: (UnsafeAtomicPointer<Int>) throws -> R
  ) rethrows -> R {
    try buffer.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomicPointer<Int>(at: header))
    }
  }

  func increment() {
    _withAtomicPointer { $0.wrappingIncrement(ordering: .relaxed) }
  }

  func load() -> Int {
    _withAtomicPointer { $0.load(ordering: .relaxed) }
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
struct AtomicUnmanagedRef<Instance: AnyObject> {
  typealias AtomicValue = Optional<Unmanaged<Instance>>

  class Buffer<Instance>: ManagedBuffer<AtomicValue.AtomicStorage, Void> {
    deinit {
      withUnsafeMutablePointerToHeader { header in
        AtomicValue.deinitializeAtomicStorage(at: header)
      }
    }
  }

  let buffer: Buffer<Instance>

  init() {
    buffer = Buffer<Instance>.create(minimumCapacity: 0) { _ in
      AtomicValue.atomicStorage(for: nil)
    } as! Buffer<Instance>
  }

  private func _withAtomicPointer<R>(
    _ body: (UnsafeAtomicPointer<AtomicValue>) throws -> R
  ) rethrows -> R {
    try buffer.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomicPointer<AtomicValue>(at: header))
    }
  }

  func store(_ desired: AtomicValue) {
    _withAtomicPointer { $0.store(desired, ordering: .sequentiallyConsistent) }
  }

  func load() -> AtomicValue {
    _withAtomicPointer { $0.load(ordering: .sequentiallyConsistent) }
  }
}
