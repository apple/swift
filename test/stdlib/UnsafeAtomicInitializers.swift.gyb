// RUN: %empty-directory(%t)
// RUN: %gyb -DCMAKE_SIZEOF_VOID_P=%target-ptrsize %s -o %t/UnsafeAtomicInitializers.swift
// RUN: %target-swift-frontend -typecheck -verify -I %t %t/UnsafeAtomicInitializers.swift

%{
  types = [
    ("UnsafeAtomicInt",    "Int", "0"),
    ("UnsafeAtomicUInt",   "UInt",  "0"),
    ("UnsafeAtomicInt64",  "Int64", "0"),
    ("UnsafeAtomicUInt64", "UInt64", "0"),
    ("UnsafeAtomicInt32",  "Int32", "0"),
    ("UnsafeAtomicUInt32", "UInt32", "0"),
    ("UnsafeAtomicInt16",  "Int16", "0"),
    ("UnsafeAtomicUInt16", "UInt16", "0"),
    ("UnsafeAtomicInt8",   "Int8", "0"),
    ("UnsafeAtomicUInt8",  "UInt8", "0"),
  ]
}%

import Atomics

class Foo {
  var value = 0
}
struct Bar {
  var value = 0
}

% for (type, base, value) in types:
@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_${type}() -> ${type} {
  var value: ${base} = ${value}
  let atomic = ${type}(at: &value) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from '${base}' to 'UnsafeMutablePointer<${type}.Value>' (aka 'UnsafeMutablePointer<${base}>') produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}
% end

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_UnsafeAtomicUnmanaged() -> UnsafeAtomicUnmanaged<Foo> {
  var value: Unmanaged<Foo>? = nil
  let atomic = UnsafeAtomicUnmanaged(at: &value) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'Unmanaged<Foo>?' to 'UnsafeMutablePointer<Unmanaged<Foo>?>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_UnsafeAtomicMutablePointer() -> UnsafeAtomicMutablePointer<Bar> {
  var value: UnsafeMutablePointer<Bar>? = nil
  let atomic = UnsafeAtomicMutablePointer(at: &value) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'UnsafeMutablePointer<Bar>?' to 'UnsafeMutablePointer<UnsafeMutablePointer<Bar>?>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
func test_UnsafeAtomicLazyReference() -> UnsafeAtomicLazyReference<Foo> {
  var value: Foo? = nil
  let atomic = UnsafeAtomicLazyReference(at: &value) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'Foo?' to 'UnsafeMutablePointer<Foo?>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
class BrokenAtomicCounter { // THIS IS BROKEN; DO NOT USE
  private var _storage = 0
  private var _value: UnsafeAtomicInt?

  init() {
    // This escapes the ephemeral pointer generated by the inout expression,
    // so it leads to undefined behavior when the pointer gets dereferenced
    // in the atomic operations below. DO NOT DO THIS.
    _value = UnsafeAtomicInt(at: &_storage) // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
    // expected-note@-1 {{implicit argument conversion from 'Int' to 'UnsafeMutablePointer<UnsafeAtomicInt.Value>' (aka 'UnsafeMutablePointer<Int>') produces a pointer valid only for the duration of the call to 'init(at:)'}}
    // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  }

  func increment() {
    _value!.wrappingIncrement(by: 1, ordering: .relaxed)
  }

  func get() -> Int {
    _value!.load(ordering: .relaxed)
  }
}

@available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *)
struct AtomicCounterRef {
  let value: ManagedBufferPointer<Int, Void>

  init() {
    value = ManagedBufferPointer(
      bufferClass: ManagedBuffer<Int, Void>.self,
      minimumCapacity: 0) { _, _ in
      0
    }
  }

  private func _withAtomicValue<R>(_ body: (UnsafeAtomicInt) throws -> R) rethrows -> R {
    try value.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomicInt(at: header))
    }
  }

  func increment() {
    _withAtomicValue { $0.wrappingIncrement(ordering: .relaxed) }
  }

  func get() -> Int {
    _withAtomicValue { $0.load(ordering: .relaxed) }
  }
}
