// RUN: %swift %s -emit-sil -module-name run | %FileCheck %s

// The main thing here is to make sure that we can read in an `alloc_ref` with
// the `[unique]` flag and print it back out without triggering SILVerifier
// errors.

sil_stage canonical

import Builtin
import Swift
import SwiftShims

public class MyClass {
  @_hasStorage @_hasInitialValue var i: Int { get set }
  deinit
  init()
}

// CHECK-LABEL: sil @simple
// CHECK: alloc_ref [stack] [unique] $MyClass
// CHECK-LABEL: end sil function 'simple'
sil @simple : $@convention(thin) () -> () {
bb0:
  %0 = alloc_ref [stack] [unique] $MyClass
  %2 = integer_literal $Builtin.Int64, 0
  %3 = struct $Int (%2 : $Builtin.Int64)
  %4 = ref_element_addr %0 : $MyClass, #MyClass.i
  %5 = begin_access [modify] [dynamic] [no_nested_conflict] %4 : $*Int
  store %3 to %5 : $*Int
  end_access %5 : $*Int
  set_deallocating %0 : $MyClass
  dealloc_ref %0 : $MyClass
  dealloc_ref [stack] %0 : $MyClass
  %14 = tuple ()
  return %14 : $()
}

// CHECK-LABEL: sil @store_then_load
// CHECK: alloc_ref [stack] [unique] $MyClass
// CHECK-LABEL: end sil function 'store_then_load'
sil @store_then_load : $@convention(thin) () -> Int {
bb0:
  %0 = alloc_ref [unique] [stack] $MyClass
  debug_value %0 : $MyClass, let, name "self", argno 1
  %2 = integer_literal $Builtin.Int64, 0
  %3 = struct $Int (%2 : $Builtin.Int64)
  %4 = ref_element_addr %0 : $MyClass, #MyClass.i
  %5 = begin_access [modify] [dynamic] [no_nested_conflict] %4 : $*Int
  store %3 to %5 : $*Int
  end_access %5 : $*Int
  debug_value %0 : $MyClass, let, name "x"
  debug_value %0 : $MyClass, let, name "self", argno 1
  %10 = begin_access [read] [static] [no_nested_conflict] %4 : $*Int
  %11 = load %10 : $*Int
  end_access %10 : $*Int
  set_deallocating %0 : $MyClass
  debug_value %0 : $MyClass, let, name "self", argno 1
  debug_value %0 : $MyClass, let, name "self", argno 1
  dealloc_ref %0 : $MyClass
  dealloc_ref [stack] %0 : $MyClass
  return %11 : $Int
}

// CHECK-LABEL: sil @multi_block
// CHECK: alloc_ref [stack] [unique] $MyClass
// CHECK-LABEL: end sil function 'multi_block'
sil @multi_block : $@convention(thin) (Bool) -> Int {
bb0(%0 : $Bool):
  %2 = alloc_ref [unique] [stack] $MyClass
  debug_value %2 : $MyClass, let, name "self", argno 1
  %4 = integer_literal $Builtin.Int64, 0
  %5 = struct $Int (%4 : $Builtin.Int64)
  %6 = ref_element_addr %2 : $MyClass, #MyClass.i
  %7 = begin_access [modify] [dynamic] [no_nested_conflict] %6 : $*Int
  store %5 to %7 : $*Int
  end_access %7 : $*Int
  %10 = struct_extract %0 : $Bool, #Bool._value
  cond_br %10, bb1, bb2

bb1:
  %13 = begin_access [read] [static] [no_nested_conflict] %6 : $*Int
  %14 = load %13 : $*Int
  end_access %13 : $*Int
  br bb3(%14 : $Int)

bb2:
  br bb3(%5 : $Int)

bb3(%20 : $Int):
  set_deallocating %2 : $MyClass
  dealloc_ref %2 : $MyClass
  dealloc_ref [stack] %2 : $MyClass
  return %20 : $Int
}

// CHECK-LABEL: sil @test_multiblock_with_branch
// CHECK: alloc_ref [stack] [unique] $MyClass
// CHECK-LABEL: end sil function 'test_multiblock_with_branch'
sil @test_multiblock_with_branch : $@convention(thin) (Bool, Bool) -> Int {
bb0(%0 : $Bool, %1 : $Bool):
  %4 = alloc_ref [stack] [unique] $Foo
  %6 = integer_literal $Builtin.Int64, 0
  %7 = struct $Int (%6 : $Builtin.Int64)
  %8 = ref_element_addr %4 : $Foo, #Foo.x
  %9 = begin_access [modify] [dynamic] [no_nested_conflict] %8 : $*Int
  store %7 to %9 : $*Int
  end_access %9 : $*Int
  %12 = struct_extract %0 : $Bool, #Bool._value
  cond_br %12, bb2, bb1

bb1:
  br bb3

bb2:
  %15 = integer_literal $Builtin.Int64, 1
  %16 = struct $Int (%15 : $Builtin.Int64)
  %19 = begin_access [modify] [static] [no_nested_conflict] %8 : $*Int
  store %16 to %19 : $*Int
  end_access %19 : $*Int
  br bb3

bb3:
  %23 = struct_extract %1 : $Bool, #Bool._value
  cond_br %23, bb4, bb5

bb4:
  %25 = alloc_ref $Foo
  %27 = ref_element_addr %25 : $Foo, #Foo.x
  %28 = begin_access [modify] [dynamic] [no_nested_conflict] %27 : $*Int
  store %7 to %28 : $*Int
  end_access %28 : $*Int
  // strong_release %4 : $Foo
  br bb6(%25 : $Foo)

bb5:
  br bb6(%4 : $Foo)

bb6(%34 : $Foo):
  %36 = ref_element_addr %34 : $Foo, #Foo.x
  %37 = begin_access [read] [dynamic] [no_nested_conflict] %36 : $*Int
  %38 = load %37 : $*Int
  end_access %37 : $*Int
  // strong_release %34 : $Foo
  dealloc_ref [stack] %4 : $Foo
  return %38 : $Int
}
