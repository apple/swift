// First parse this and then emit a *.sib. Then read in the *.sib, then recreate
// RUN: %empty-directory(%t)
// RUN: %target-sil-opt %s -emit-sib -o %t/tmp.sib -module-name unmanaged
// RUN: %target-sil-opt %t/tmp.sib -o %t/tmp.2.sib -module-name unmanaged
// RUN: %target-sil-opt %t/tmp.2.sib -module-name unmanaged | %FileCheck %s

import Swift
import Builtin

class C {}

// CHECK-LABEL: sil [serialized] @retain_release : $@convention(thin) (@sil_unmanaged C) -> () {
// CHECK: bb0([[ARG:%.*]] : $@sil_unmanaged C):
// CHECK: [[REF:%.*]] = unmanaged_to_ref [[ARG]] : $@sil_unmanaged C to $C
// CHECK: unmanaged_retain_value [[REF]]
// CHECK: unmanaged_autorelease_value [[REF]]
// CHECK: unmanaged_release_value [[REF]]
sil [serialized] @retain_release : $@convention(thin) (@sil_unmanaged C) -> () {
bb0(%0 : $@sil_unmanaged C):
  %1 = unmanaged_to_ref %0 : $@sil_unmanaged C to $C
  unmanaged_retain_value %1 : $C
  unmanaged_autorelease_value %1 : $C
  unmanaged_release_value %1 : $C
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [serialized] @test : $@convention(thin) <U where U : AnyObject> (@inout U) -> () {
// CHECK: bb0([[ARG:%.*]] : $*U):
// CHECK: [[LOADED_ARG:%.*]] = load [copy] [[ARG]]
// CHECK: [[UNMANAGED_LOADED_ARG:%.*]] = ref_to_unmanaged [[LOADED_ARG]] : $U to $@sil_unmanaged U
// CHECK: {{%.*}} = unmanaged_to_ref [[UNMANAGED_LOADED_ARG]] : $@sil_unmanaged U to $U
// CHECK: destroy_value [[LOADED_ARG]]
sil [serialized] @test : $@convention(thin) <U where U : AnyObject> (@inout U) -> () {
bb0(%0 : $*U):
  %1 = load [copy] %0 : $*U
  %2 = ref_to_unmanaged %1 : $U to $@sil_unmanaged U
  %3 = unmanaged_to_ref %2 : $@sil_unmanaged U to $U
  destroy_value %1 : $U
  %9999 = tuple ()
  return %9999 : $()
}
