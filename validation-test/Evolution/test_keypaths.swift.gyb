// RUN: %empty-directory(%t)
// RUN: %empty-directory(%t/Inputs)
// RUN: %empty-directory(%t/rth)
// RUN: env PYTHONPATH=%S/Inputs %gyb < %s > %t/test_keypaths.swift
// RUN: env PYTHONPATH=%S/Inputs %gyb < %S/Inputs/keypaths.swift.gyb > %t/Inputs/keypaths.swift
// RUN: %rth --target-build-swift "%target-build-swift" --target-run "%target-run" --t "%t/rth" --S "%t" --s "%t/test_keypaths.swift" --lib-prefix "lib" --lib-suffix "%{target-shared-library-suffix}" --target-codesign "%target-codesign" --no-symbol-diff

// REQUIRES: executable_test

// Uses swift-version 4.
// UNSUPPORTED: swift_test_mode_optimize_none_with_implicit_dynamic

import keypaths
import StdlibUnittest

%{
from keypaths_gyb import testCases
}%

var tests = TestSuite("key path resilience")

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%  if addsAPI:
#if BEFORE
%  end

%  if kind == "mutating" or kind == "nonmutating":

tests.test("AnEnum.${name}") {
  let fromModule = AnEnum.keyPath_${name}
  let formedLocally = \AnEnum${typeSuffix}.${name}

  expectEqual(fromModule, formedLocally)
}

%  elif kind == "stored":

%  else:
     %{ raise ValueError("improper test case kind") }%
%  end

%  if addsAPI:
#endif // BEFORE
%  end

% end

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%  if addsAPI:
#if BEFORE
%  end

%  if kind == "mutating" or kind == "nonmutating" or kind == "stored":

tests.test("AStruct.${name}") {
  let fromModule = AStruct.keyPath_${name}
  let formedLocally = \AStruct${typeSuffix}.${name}

  expectEqual(fromModule, formedLocally)
}

%  else:
     %{ raise ValueError("improper test case kind") }%
%  end

%  if addsAPI:
#endif // BEFORE
%  end

% end

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%  if addsAPI:
#if BEFORE
%  end

%  if kind == "nonmutating" or kind == "stored":

tests.test("AClass.${name}") {
  let fromModule = AClass.keyPath_${name}
  let formedLocally = \AClass${typeSuffix}.${name}

  expectEqual(fromModule, formedLocally)
}

tests.test("AFinalClass.${name}") {
  let fromModule = AFinalClass.keyPath_${name}
  let formedLocally = \AFinalClass${typeSuffix}.${name}

  expectEqual(fromModule, formedLocally)
}

%  elif kind == "mutating":

%  else:
     %{ raise ValueError("improper test case kind") }%
%  end

%  if addsAPI:
#endif
%  end

% end

#if !BEFORE
// In backwards deployment, static properties will not have property
// descriptors. As a result, we expect key path equality to show certain flaws,
// but the key paths should still otherwise be usable.

% for typeName in ("AnEnum", "AStruct", "AClass", "AFinalClass"):
tests.test("${typeName}.staticBackDeployEquality") {
  let fromModule = ${typeName}.keyPath_staticBackDeploy
  let formedLocally = \${typeName}.Type.staticBackDeploy
  let otherFromModule = ${typeName}.keyPath_staticBackDeployOther
  let otherFormedLocally = \${typeName}.Type.staticBackDeployOther
  
  // Always correct behavior
  expectNotEqual(fromModule, otherFromModule)
  expectNotEqual(formedLocally, otherFormedLocally)
    expectEqual(formedLocally, fromModule)
    expectEqual(otherFormedLocally, otherFromModule)

  if isBeforeLibrary {
    // Correct behavior when using a module compiled by Swift 5.1+
  }
  else {
    // Incorrect behavior when using a module compiled by Swift 5.0
//    expectNotEqual(fromModule, formedLocally)
//    expectNotEqual(otherFromModule, otherFormedLocally)
  }
}
%end
#endif

runAllTests()
