
%{
from keypaths_gyb import testCases
}%

#if BEFORE
public let isBeforeLibrary = true
#else
public let isBeforeLibrary = false
#endif

public var globalSink: Int = 0

public enum AnEnum {

  case unset, set(Int)

  init() { self = .unset }

  public var sink: Int {
    get {
      switch self {
      case .unset:
        return 0
      case .set(let x):
        return x
      }
    }
    set {
      self = .set(newValue)
    }
  }

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%   if kind == "mutating" or kind == "nonmutating":

    #if BEFORE
      ${before.format(name=name, nonmutating="nonmutating", type="AnEnum")}
    #else
      ${after.format(name=name, nonmutating="nonmutating", type="AnEnum")}
    #endif

    public static var keyPath_${name}: PartialKeyPath<AnEnum${typeSuffix}> { return \AnEnum${typeSuffix}.${name} }
      
%   elif kind == "stored":

%   else:
      %{ raise ValueError("improper test case kind") }%
%   end

% end

}

public struct AStruct {

  public var sink: Int = 0

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%   if kind == "mutating" or kind == "nonmutating" or kind == "stored":

    #if BEFORE
      ${before.format(name=name, nonmutating="nonmutating", type="AStruct")}
    #else
      ${after.format(name=name, nonmutating="nonmutating", type="AStruct")}
    #endif

    public static var keyPath_${name}: PartialKeyPath<AStruct${typeSuffix}> { return \AStruct${typeSuffix}.${name} }

%   else:
      %{ raise ValueError("improper test case kind") }%
%   end

% end

}

public class AClass {

  public var sink: Int = 0

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%   if kind == "nonmutating" or kind == "stored":

    #if BEFORE
      ${before.format(name=name, nonmutating="", type="AClass")}
    #else
      ${after.format(name=name, nonmutating="", type="AClass")}
    #endif

    public static var keyPath_${name}: PartialKeyPath<AClass${typeSuffix}> { return \AClass${typeSuffix}.${name} }

%   elif kind == "mutating":

%   else:
      %{ raise ValueError("improper test case kind") }%
%   end

% end

}

public final class AFinalClass {

  public var sink: Int = 0

% for (name, kind, before, after, addsAPI, typeSuffix) in testCases:

%   if kind == "nonmutating" or kind == "stored":

    #if BEFORE
      ${before.format(name=name, nonmutating="", type="AFinalClass")}
    #else
      ${after.format(name=name, nonmutating="", type="AFinalClass")}
    #endif

    public static var keyPath_${name}: PartialKeyPath<AFinalClass${typeSuffix}> { return \AFinalClass${typeSuffix}.${name} }

%   elif kind == "mutating":

%   else:
      %{ raise ValueError("improper test case kind") }%
%   end

% end

}

