// RUN: rm -rf %t
// RUN: mkdir -p %t
// RUN: %gyb %s -o %t/ArrayTraps.swift
// RUN: %line-directive %t/ArrayTraps.swift -- %target-build-swift %t/ArrayTraps.swift -o %t/a.out_Debug
// RUN: %line-directive %t/ArrayTraps.swift -- %target-build-swift %t/ArrayTraps.swift -o %t/a.out_Release -O
//
// RUN: %line-directive %t/ArrayTraps.swift -- %target-run %t/a.out_Debug
// RUN: %line-directive %t/ArrayTraps.swift -- %target-run %t/a.out_Release
// REQUIRES: executable_test
// REQUIRES: objc_interop

import StdlibUnittest
import Foundation

let testSuiteSuffix = _isDebugAssertConfiguration() ? "_debug" : "_release"

var ArrayTraps = TestSuite("ArrayTraps" + testSuiteSuffix)

class Base { }
class Derived : Base { }
class Derived2 : Derived { }

ArrayTraps.test("downcast1")
  .skip(.custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let ba: [Base] = [ Derived(), Base() ]
  expectCrashLater()
  let da = ba as! [Derived]
}

ArrayTraps.test("downcast2")
  .skip(.custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let a: [AnyObject] = ["String" as NSString, 1 as NSNumber]
  expectCrashLater()
  let sa = a as! [NSString]
}

ArrayTraps.test("downcast3")
  .skip(.custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let ba: [Base] = [ Derived2(), Derived(), Base() ]
  expectCrashLater()
  let d2a = ba as! [Derived2]
}

@objc protocol ObjCProto { }
class ObjCBase : NSObject, ObjCProto { }
class ObjCDerived : ObjCBase { }

ArrayTraps.test("downcast4")
  .skip(.custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let ba: [ObjCProto] = [ ObjCDerived(), ObjCBase() ]
  expectCrashLater()
  let da = ba as! [ObjCDerived]
}

ArrayTraps.test("bounds_with_downcast")
  .skip(.custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let ba: [Base] = [ Derived(), Base() ]
  expectCrashLater()
  let da = ba as! [Derived]
}

var ArraySemanticOptzns = TestSuite("ArraySemanticOptzns" + testSuiteSuffix)

class BaseClass {
}

class ElementClass : BaseClass {
  var val: String
  init(_ x: String) {
    val = x
  }
}

class ViolateInoutSafetyNeedElementTypeCheck {
  final var anArray : [ElementClass] = []

  @inline(never)
  func accessArrayViaInoutViolation() {
    // Overwrite the array with one that needs an element type check.
    let ba: [BaseClass] = [ BaseClass(), BaseClass() ]
    anArray = ba as! [ElementClass]
  }

  @inline(never)
  func runLoop(_ A: inout [ElementClass]) {
    // Simulate what happens if we hoist array properties out of a loop and the
    // loop calls a function that violates inout safety and overrides the array.
    let isNativeTypeChecked = A._hoistableIsNativeTypeChecked()
    for i in 0..<A.count {
      let t = A._checkSubscript(
        i, wasNativeTypeChecked: isNativeTypeChecked)
      _ = A._getElement(
        i, wasNativeTypeChecked: isNativeTypeChecked, matchingSubscriptCheck: t)
      accessArrayViaInoutViolation()
    }
  }

  @inline(never)
  func inoutViolation() {
    anArray = [ ElementClass("1"), ElementClass("2"), ElementClass("3")]
    runLoop(&anArray)
  }
}

runAllTests()
