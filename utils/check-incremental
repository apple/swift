#!/usr/bin/env python
# check-incremental - Check if incremental compilation works -*- python -*-
#
# This source file is part of the Swift.org open source project
#
# Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See http://swift.org/LICENSE.txt for license information
# See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
"""
Wrapper for the Swift compiler.

It invokes the compiler multiple times, and checks if the output object
file is only written once.  This checks that the compiler is deterministic.
"""

from __future__ import print_function

import argparse
import os
import subprocess
import sys


NUM_ITERATIONS = 4
VERBOSE = False


def get_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(__doc__)

    parser.add_argument('-o', metavar='OUTPUT_FILE', required=True,
                        help='output file to compare')
    parser.add_argument('-c', required=True,
                        action='store_true', dest='write_obj_file',
                        help='write_obj_file')  # @@AWLC: wut?
    parser.add_argument('-disable-incremental-llvm-codegen',
                        action='store_false', dest='compare_time',
                        help='compare times on the generated files')

    return parser.parse_args()


def compile_and_check(output_file):
    """Calls the build arguments with subprocess, then returns a tuple
    containing the MD5 sum and last modification time of the
    output file.
    """
    subprocess.check_call(sys.argv[1:])

    if VERBOSE:
        print("Reference compilation of %s:" % output_file)

    md5sum = subprocess.check_output(["md5", "-q", output_file])
    mtime = os.path.getmtime(output_file)

    if VERBOSE:
        print("  time = %s" % mtime)
        print("  md5  = %s" % md5sum)

    return (md5sum, mtime)


def main():

    args = get_arguments()

    reference_md5, reference_time = compile_and_check(args.output_file)
    subprocess.check_call(
        ["cp", args.output_file, args.output_file + ".ref.o"])

    for iteration in range(NUM_ITERATIONS):
        if VERBOSE:
            print("Iteration %s:" % iteration)
        second_md5, second_time = compile_and_check(args.output_file)

        # This is the most important check: is the output file exactly the
        # same?
        if reference_md5 != second_md5:
            print("Non-determinism when generating: %s" % args.output_file,
                  file=sys.stderr)
            sys.exit(1)

        # This is the bonus check: does the compiler not re-write the output
        # file? (For compilations < 1sec this check may succeed even if the
        # file was overwritten).
        if args.compare_time and (reference_time != second_time):
            print("File re-written: %s" % args.output_file,
                  file=sys.stderr)
            sys.exit(1)


if __name__ == '__main__':
    main()
